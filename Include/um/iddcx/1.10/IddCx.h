/*++

Copyright (c) Microsoft Corporation. All Rights Reserved

Module Name:

    IddCx.h

Abstract:

    Indirect Displays class extension and the client driver interface.

Environment:

    User-mode Driver Framework

--*/

#ifndef DXVA2_API_DEFINED
#define DXVA2_API_DEFINED
#endif
#ifndef DO_NOT_USE_DIRECTX_OR_DXVA2
#define DO_NOT_USE_DIRECTX_OR_DXVA2
#endif
#include <Opmapi.h>

#include <Dxgi.h>
#include <d3d11_4.h>

//
// NOTE: This header is generated by stubwork.  Please make any 
//       modifications to the corresponding template files 
//       (.x or .y) and use stubwork to regenerate the header
//

#ifndef _IDDCX_H_
#define _IDDCX_H_

#ifndef WDF_EXTERN_C
  #ifdef __cplusplus
    #define WDF_EXTERN_C       extern "C"
    #define WDF_EXTERN_C_START extern "C" {
    #define WDF_EXTERN_C_END   }
  #else
    #define WDF_EXTERN_C
    #define WDF_EXTERN_C_START
    #define WDF_EXTERN_C_END
  #endif
#endif

WDF_EXTERN_C_START



#ifndef WDFAPI
#error Include WDF.H first
#endif

// Disable warning 'nonstandard extension used : nameless struct/union'
#pragma warning(push)
#pragma warning(disable : 4201)

// DDI Version model
// -----------------
// The interface version model will be based on structure versions, when a DDI call/OS callback needs to be updated
// the version of that callback we be incremented along with any structures used, for example if v1 of a call was :
//
//     void SomeDDICall(IDDCX_ADAPTER hOsAdapterContext, IDARG_IN_SOME_DDI* pInArgs);
//
// and the functionality/params needed to be changed then the following would be added:
//
//     void SomeDDICall2(IDDCX_ADAPTER hOsAdapterContext, IDARG_IN_SOME_DDI2* pInArgs);
//
// and the DDI function table structure would be updated to IDDCX_DDI2 which would have SomeDDICall replaced with
// SomeDDICall2.  At the same time a new create interface v2 would be used by a driver

// IDDCX Version model
// -------------------
// In order for drivers to know precisely which version of IddCx the driver is running the driver can call the
// IddCxGetVersion() callback.  This helps if IddCx bug that effect behavior are fixed and released within a given OS release,
// for example if a IddCx bug was fixed in the Windows 10 Creators Update after release and the driver needed to know if the
// IddCx being used had that fix they could use IddCxGetVersion()

#define IDDCX_VERSION_RS3 0x1200
#define IDDCX_VERSION_RS4 0x1300
#define IDDCX_VERSION_RS5 0x1380
#define IDDCX_VERSION_19H1 0x1400
#define IDDCX_VERSION_VIBRAINIUM 0x1500
#define IDDCX_VERSION_MANGANESE 0x1600
#define IDDCX_VERSION_IRON 0x1700
#define IDDCX_VERSION_COBALT 0x1800
#define IDDCX_VERSION_COBALT_UPDATEMODE_FIX 0x1801
#define IDDCX_VERSION_SV2 0x1900
#define IDDCX_VERSION_SV2_SEPT23 0x1A00
#define IDDCX_VERSION_GERMANIUM 0x1A80
#define IDDCX_VERSION_LATEST IDDCX_VERSION_GERMANIUM


// Timeout detection and recovery
// ------------------------------
// The OS will monitor the drivers processing of frames and if it detects the driver is not making forward progress it will
// take action to ensure the desktop is not effected.
// The OS will monitor the driver in two ways :
//
// 1) Ensure that each OS->driver call does not take longer than 10 seconds
// 2) Ensure that a driver reports that it has finished process a given frame within 10 seconds, that is that the driver does
//    not call FinishedProcessingFrame() within 10 seconds of the new frame ready event is triggered
//
// In the event of a timeout being detected then the OS will call the UMDF BugCheck() call which will cause the UMDF host
// process to terminate and restart subject to UMDF device restart policy.

/// <summary>
/// Opaque reference to a WDF indirect display adapter object
/// </summary>
DECLARE_HANDLE(IDDCX_ADAPTER);

/// <summary>
/// Opaque reference to a WDF indirect display monitor object
/// </summary>
DECLARE_HANDLE(IDDCX_MONITOR);

/// <summary>
/// Opaque reference to a WDF indirect display swap-chain object.
/// </summary>
DECLARE_HANDLE(IDDCX_SWAPCHAIN);

/// <summary>
/// Opaque reference to a WDF indirect display OPM output protection context
/// </summary>
DECLARE_HANDLE(IDDCX_OPMCTX);

#pragma region Enum Declarations

/// <summary>
/// Enum used to indicates how a given supported feature is implemented
/// </summary>
enum IDDCX_FEATURE_IMPLEMENTATION : UINT
{
    IDDCX_FEATURE_IMPLEMENTATION_UNINITIALIZED = 0,
    /// <summary>
    /// The feature is not implemented
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION_NONE = 1,
    /// <summary>
    /// The feature is implemented and hardware is used in the implementation. For example, the adapter
    /// display pipeline blends the hardware cursor image into the signal sent to the monitor.
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION_HARDWARE = 2,
    /// <summary>
    /// The feature is implemented and software is used in the implementation. For example, the driver
    /// support hardware cursor by blending the cursor image into the display pixels as part of the processing.
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION_SOFTWARE = 3,
};

/// <summary>
/// Enum used to indicates the link type for transmission of the video data
/// </summary>
enum IDDCX_TRANSMISSION_TYPE : UINT
{
    IDDCX_TRANSMISSION_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// Video data is being transmitted over wired USB
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRED_USB = 0x1,
    /// <summary>
    /// Video data is being transmitted over wired Miracast link
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRED_MIRACAST = 0x2,
    /// <summary>
    /// Video data is being transmitted over a wired connect not already described
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRED_OTHER = 0x3,
    /// <summary>
    /// Video data is being transmitted over wireless MA-USB
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_MAUSB = 0x4,
    /// <summary>
    /// Video data is being transmitted over wireless network not using MA-USB but the device
    /// is enumerated on the USB bus
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_USB_OTHER = 0x5,
    /// <summary>
    /// Video data is being transmitted over a WiFi wireless network
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_WIFI_OTHER = 0x6,
    /// <summary>
    /// Video data is being transmitted over wireless Miracast link
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_MIRACAST = 0x7,
    /// <summary>
    /// Video data is being transmitted over a non-WiFi wireless network not described above
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_OTHER = 0x8,
    /// <summary>
    /// Video data is being transmitted over TCP/UDP/IP network not described above
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_NETWORK_OTHER = 0x9,
    /// <summary>
    /// Video data is being transmitted over a link type that is not covered by the above defines
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_OTHER = 0xFFFFFFFF,
};

/// <summary>
/// Specifies boolean flags for an indirect display adapter.
/// </summary>
enum IDDCX_ADAPTER_FLAGS : UINT
{
    IDDCX_ADAPTER_FLAGS_NONE = 0,
    /// <summary>
    /// Indirect display automatically support OS virtual modes, this means mode changes can be
    /// performed seamlessly by OS using DWM scaling on a per frame basis without any display mode
    /// change. The disadvantage of this is that when a smaller desktop mode is used by the user the
    /// desktop image provided to the driver to process will be bigger than the desktop size hence
    /// wasting some encode and transmit bandwidth. This value is used to indicate to the OS that the
    /// smallest possible desktop surface size should be used when the desktop mode is changed.
    /// Typically a solution that has a large processing overhead or limited transmission bandwidth will
    /// use this flag reduce the desktop image size to process as much as possible.Note setting this flag
    /// will result in a mode change each time the desktop resolution is changed.
    /// </summary>
    IDDCX_ADAPTER_FLAGS_USE_SMALLEST_MODE = 0x1,
    /// <summary>
    /// Indicates if the driver can utilize move regions provided by the OS in addition to dirty rects when
    /// encoding the image.  The driver should only set this to TRUE if it will use the move regions as it does
    /// cost additional resource for the OS to generate these.
    /// If driver sets this to FALSE the OS will convert all move regions in to dirty rects
    /// </summary>
    IDDCX_ADAPTER_FLAGS_CAN_USE_MOVE_REGIONS = 0x2,
    /// <summary>
    /// Indicates if the driver is a remote session driver supporting remote session monitors rather than console
    /// session monitors.  A remote session driver cannot support console session monitors and console session driver
    /// cannot support remote session monitors.
    /// </summary>
    IDDCX_ADAPTER_FLAGS_REMOTE_SESSION_DRIVER = 0x4,
    /// <summary>
    /// Indicates that the driver perfers physically contiguous memory to be used for swap chain buffers allowing
    // the driver to directly scan out the buffers and eliminating the need for an intermediate copy.
    /// </summary>
    IDDCX_ADAPTER_FLAGS_PREFER_PHYSICALLY_CONTIGUOUS = 0x8,
    /// <summary>
    /// Indicates that the remote driver wants to receive all cursor position changes rather than just the
    /// procedural moves.  Only valid if IDDCX_ADAPTER_FLAGS_REMOTE_SESSION_DRIVER is set
    /// </summary>
    IDDCX_ADAPTER_FLAGS_REMOTE_ALL_CURSOR_POSITION = 0x10,
    /// <summary>
    /// Indicates that driver prefers more accurate dirty rects even if it costs slightly more CPU usage to track them
    /// </summary>
    IDDCX_ADAPTER_FLAGS_PREFER_PRECISE_PRESENT_REGIONS = 0x20,
    /// <summary>
    /// Indicates the driver can process FP16 swapchain surfaces. Although this is an adapter flag a driver should still
    /// set IDDCX_ADAPTER_FLAGS_CAN_PROCESS_FP16 even for adapters that do not support HDR or SDR WCG. HDR or SDR WCG
    /// surfaces and modes will be sent to the driver when the right combination of monitor, target capabilities, OS
    /// settings, etc. are in place so it is a requirement that a driver setting IDDCX_ADAPTER_FLAGS_CAN_PROCESS_FP16
    /// must also support the new functions that allow this to happen.
    /// </summary>
    IDDCX_ADAPTER_FLAGS_CAN_PROCESS_FP16 = 0x40,
    /// <summary>
    /// If a driver sets IDDCX_ADAPTER_FLAGS_REMOTE_ALL_TARGET_MODES_MONITOR_COMPATIBLE it means every target mode
    /// reported in calls to EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES2 and IddCxMonitorUpdateModes2 is guaranteed to be
    /// compatible with the currently connected monitor. The OS will then not call EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION2
    /// or EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES. It is only valid for remote drivers to set this flag.
    /// </summary>
    IDDCX_ADAPTER_FLAGS_REMOTE_ALL_TARGET_MODES_MONITOR_COMPATIBLE = 0x80,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_ADAPTER_FLAGS);

/// <summary>
///  Used to describe the monitor description
/// </summary>
enum IDDCX_MONITOR_DESCRIPTION_TYPE : UINT
{
    IDDCX_MONITOR_DESCRIPTION_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// The monitor description is EDID or no EDID description available
    /// If the monitor has no description then IDDCX_MONITOR_DESCRIPTION_TYPE_EDID shall be used with zero description size
    /// and null pointer for data
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION_TYPE_EDID = 1,
    /// <summary>
    /// For the monitors with DisplayID and EDID
    /// The monitor description starts with DisplayID followed by EDID without any padding in between
    /// EDID should contain all available data blocks and shall be present
    /// The call to connect monitor will fail if DisplayID is missing or invalid, or if EDID is missing
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION_TYPE_DISPLAYID_AND_EDID = 2,
};

/// <summary>
/// Used to describe a mode the monitor supports based on the monitor description.
/// </summary>
enum IDDCX_MONITOR_MODE_ORIGIN : UINT
{
    IDDCX_MONITOR_MODE_ORIGIN_UNINITIALIZED = 0,
    /// <summary>
    /// Indicates that the driver added this mode from directly processing the monitor description
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN_MONITORDESCRIPTOR = 1,
    /// <summary>
    /// Indicates that the driver did not add this mode as a direct resolution of processing the modes
    /// supported by the monitor but because of separate additional knowledge it has about the monitor
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN_DRIVER = 2,
};

/// <summary>
/// Describes why the driver is calling to update the mode list
/// </summary>
enum IDDCX_UPDATE_REASON : UINT
{
    IDDCX_UPDATE_REASON_UNINITIALIZED = 0,
    /// <summary>
    /// The mode list is changing due to power constraints on the host system changed
    /// </summary>
    IDDCX_UPDATE_REASON_POWER_CONSTRAINTS = 1,
    /// <summary>
    /// The mode list is changing due to changes in bandwidth between the system and the indirect display device
    /// </summary>
    IDDCX_UPDATE_REASON_HOST_LINK_BANDWIDTH = 2,
    /// <summary>
    /// The mode list is changing due to changes in bandwidth the indirect display device and the monitor
    /// </summary>
    IDDCX_UPDATE_REASON_DISPLAY_LINK_BANDWIDTH = 3,
    /// <summary>
    /// The mode list is changing due to constraints of the product when in a new configuration
    /// </summary>
    IDDCX_UPDATE_REASON_CONFIGURATION_CONSTRAINTS = 4,
    /// <summary>
    /// The mode list is changing due to another reason not listed above
    /// </summary>
    IDDCX_UPDATE_REASON_OTHER = 5,
};

enum IDDCX_PATH_FLAGS : UINT
{
    IDDCX_PATH_FLAGS_NONE = 0,
    /// <summary>
    /// Indicates if this path has changed
    /// </summary>
    IDDCX_PATH_FLAGS_CHANGED = 0x1,
    /// <summary>
    /// Indicates if this path is active
    /// </summary>
    IDDCX_PATH_FLAGS_ACTIVE = 0x2,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_PATH_FLAGS);

/// <summary>
/// Describes what type of support a driver has for the given Xor cursor format.
/// If driver cannot support a particular monochrome Xor or color Xor cursor it can use the
/// IDDCX_XOR_CURSOR_SUPPORT_EMULATION value to indicate to the OS that it
/// should use it's Xor emulation algorithm to convert the Xor image to alpha cursor and have the
/// driver accelerate that.  This emulation places a solid border around the cursor image so it
/// can be seen in solid color regions of the screen.  The advantages of this is that is allows
/// the Xor cursor to be hardware accelerated when the adapter cannot support Xor, this is very
/// useful on high latency solutions as this typically allows driver to send the cursor information
/// over a sideband channel to reduce the latency.  The disadvantage is that the user will notice a
/// visual difference due to the emulation.  The recommendation is not to use this on a low latency
/// solution where falling back to software cursor will not impact the mouse latency for the
/// user (<50ms) and will result in a better visible experience.  On a high latency solution where
/// the cursor data can be transmitted independently of the desktop image it is recommended to use
/// this flag to allow hardware cursor and hence lower the mouse movement latency.
/// </summary>
enum IDDCX_XOR_CURSOR_SUPPORT : UINT
{
    IDDCX_XOR_CURSOR_SUPPORT_UNINITIALIZED = 0,
    /// <summary>
    /// Driver does not support this Xor cursor type at all, all cursors of this type will be drawn into the desktop image by
    /// the OS
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT_NONE = 1,
    /// <summary>
    /// Driver does support this Xor cursor type
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT_FULL = 2,
    /// <summary>
    /// The driver does not support this Xor cursor type but driver wants OS to convert the Xor cursor into a alpha cursor,
    /// see comment above
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT_EMULATION = 3,
};

/// <summary>
/// Describes the type of cursor
/// </summary>
enum IDDCX_CURSOR_SHAPE_TYPE : UINT
{
    IDDCX_CURSOR_SHAPE_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// Indicates this is a masked-color cursor shape
    /// </summary>
    IDDCX_CURSOR_SHAPE_TYPE_MASKED_COLOR = 1,
    /// <summary>
    /// Indicates this is a 32bpp alpha cursor
    /// </summary>
    IDDCX_CURSOR_SHAPE_TYPE_ALPHA = 2,
};

/// <summary>
/// Defines the processing status of the frame
/// </summary>
enum IDDCX_FRAME_STATUS : UINT
{
    IDDCX_FRAME_STATUS_UNINITIALIZED = 0,
    /// <summary>
    /// Indicates that the frame was processed completely and sent to the device
    /// </summary>
    IDDCX_FRAME_STATUS_COMPLETED = 1,
    /// <summary>
    /// Indicates that the driver stopped processing this frame to start on a newer frame, this normally
    /// happens if it is taking a long time to process/transmit the frame
    /// </summary>
    IDDCX_FRAME_STATUS_DROPPED = 2,
    /// <summary>
    /// Indicates that the driver stopped processing this frame because driver hit an internal error
    /// </summary>
    IDDCX_FRAME_STATUS_ERROR = 3,
};

/// <summary>
/// Defines the type of frame processing step
/// </summary>
enum IDDCX_FRAME_STATISTICS_STEP_TYPE : UINT
{
    IDDCX_FRAME_STATISTICS_STEP_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// Used to mark the start of a color convert operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_COLOR_CONVERT_START = 0x1,
    /// <summary>
    /// Used to mark the end of a color convert operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_COLOR_CONVERT_END = 0x2,
    /// <summary>
    /// Used to mark the start of a encode operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCODE_START = 0x3,
    /// <summary>
    /// Used to mark the end of a encode operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCODE_END = 0x4,
    /// <summary>
    /// Used to mark the start of a encrypt operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCRYPT_START = 0x5,
    /// <summary>
    /// Used to mark the end of a encrypt operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCRYPT_END = 0x6,
    /// <summary>
    /// Used to mark the start of a mux'ing operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_MUX_START = 0x7,
    /// <summary>
    /// Used to mark the end of a mux'ing operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_MUX_END = 0x8,
    /// <summary>
    /// Driver defined processing steps points.
    /// There are 256 single point events defined that the driver can use, each just records a single QPC time
    /// Valid driver values valid 0x100 - 0x1FF
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_1 = 0x100,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_2 = 0x101,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_3 = 0x102,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_4 = 0x103,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_5 = 0x104,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_6 = 0x105,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_7 = 0x106,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_8 = 0x107,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_9 = 0x108,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_10 = 0x109,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_256 = 0x1FF,
    /// <summary>
    /// Driver defined processing step intervals.
    /// There are 256 different intervals each with a start and end point defined.
    /// It is invalid to report either start or end without the other or for the start
    /// step to have a QPC time after the QPC time in the end step
    /// Valid start step values are 0x200 - 0x2FFF
    /// Valid end step values are 0x300 - 0x3FFF
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_1 = 0x200,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_1 = 0x300,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_2 = 0x201,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_2 = 0x301,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_3 = 0x202,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_3 = 0x302,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_256 = 0x2FF,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_256 = 0x3FF,
};

enum IDDCX_FRAME_STATISTICS_FLAGS : UINT
{
    IDDCX_FRAME_STATISTICS_FLAGS_NONE = 0,
    /// <summary>
    /// If set indicates that the driver reduced the color fidelity of the desktop image while processing
    /// and transmitting this frame
    /// </summary>
    IDDCX_FRAME_STATISTICS_FLAGS_REDUCED_COLOR_FIDELITY = 0x1,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_FRAME_STATISTICS_FLAGS);

/// <summary>
/// The type of gamma ramp being set
/// </summary>
enum IDDCX_GAMMARAMP_TYPE : UINT
{
    IDDCX_GAMMARAMP_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// The gamma ramp is the default ramp
    /// </summary>
    IDDCX_GAMMARAMP_TYPE_DEFAULT = 1,
    /// <summary>
    /// Indicates that the gamma lookup table contains three arrays, one each for the red, green, and blue color channels.
    /// Each array has 256 16-bit values.
    /// </summary>
    IDDCX_GAMMARAMP_TYPE_RGB256x3x16 = 2,
    /// <summary>
    /// The gamma lookup table contains a 3x4 matrix, a scalar multiplier and a LUT. During a call to EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP a driver
    ///  can cast the EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP::pGammaRampData pointer to a IDDCX_GAMMARAMP_3X4_COLORSPACE_TRANSFORM pointer. This will
    /// only be specified for console drivers.
    /// </summary>
    IDDCX_GAMMARAMP_TYPE_3x4_COLORSPACE_TRANSFORM = 3,
};

enum IDDCX_TARGET_CAPS : UINT
{
    /// Indicates the target supports none of capabilities available.
    /// </summary>
    IDDCX_TARGET_CAPS_NONE = 0,
    /// <summary>
    /// If set, the driver has the ability to transform RGB values from the gamut defined by the sRGB/709 primaries to the monitor's primaries.
    /// The driver can also send any necessary control signaling to the monitor to indicate the correct interpretation of the pixel data being
    /// sent. This includes handling signed input in the range (-2.0 to 2.0). The driver must do this with all supported input surface formats
    /// including 8888 and FP16.
    /// </summary>
    IDDCX_TARGET_CAPS_WIDE_COLOR_SPACE = 0x1,
    /// <summary>
    /// If set, the driver supports all of the above WideColorSpace gamut functionality and also has the ability to apply the appropriate transfer
    /// curve for that display. This means accepting canonical color space data in the range [-128.0 to 256.0] and sending any necessary control
    /// signaling to the connected display to indicate the correct interpretation.
    /// Note: setting IDDCX_TARGET_CAPS_HIGH_COLOR_SPACE is not a replacement for setting IDDCX_TARGET_CAPS_WIDE_COLOR_SPACE, drivers that support
    /// IDDCX_TARGET_CAPS_HIGH_COLOR_SPACE should also set IDDCX_TARGET_CAPS_WIDE_COLOR_SPACE.
    /// </summary>
    IDDCX_TARGET_CAPS_HIGH_COLOR_SPACE = 0x2,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_TARGET_CAPS);

enum IDDCX_BITS_PER_COMPONENT : UINT
{
    /// A driver can use this flag to indicate no support for a particular wire encoding format, for example in calls toEVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO
    /// or EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES2. When it is used as an input in the driver, for example as part of a call to EVT_IDD_CX_ADAPTER_COMMIT_MODES2,
    /// this value will never be used.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT_NONE = 0,
    /// <summary>
    /// For driver reporting, indicates support for sending color component values using 6 bits. For driver information, indicates 6 bits per
    /// component should be sent to the monitor.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT_6 = 0x01,
    /// <summary>
    /// For driver reporting, indicates support for sending color component values using 8 bits. For driver information, indicates 8 bits per component
    /// should be sent to the monitor.
    IDDCX_BITS_PER_COMPONENT_8 = 0x02,
    /// <summary>
    /// For driver reporting, indicates support for sending color component values using 10 bits. For driver information, indicates 10 bits per component
    /// should be sent to the monitor.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT_10 = 0x04,
    /// <summary>
    /// For driver reporting, indicates support for sending color component values using 12 bits. For driver information, indicates 12 bits per component
    /// should be sent to the monitor.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT_12 = 0x08,
    /// <summary>
    /// For driver reporting, indicates support for sending color component values using 14 bits. For driver information, indicates 14 bits per component
    /// should be sent to the monitor.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT_14 = 0x10,
    /// <summary>
    /// For driver reporting, indicates support for sending color component values using 16 bits. For driver information, indicates 16 bits per component
    /// should be sent to the monitor.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT_16 = 0x20,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_BITS_PER_COMPONENT);

enum IDDCX_DEFAULT_HDR_METADATA_TYPE : UINT
{
    /// Indicates that an IDDCX_DEFAULT_HDR_METADATA_TYPE variable has not yet been assigned a meaningful value.
    /// </summary>
    IDDCX_HDRMETADATA_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// The meta data being referred to is an HDR10 meta data block.
    /// </summary>
    IDDCX_HDRMETADATA_TYPE_HDR10 = 1,
};

enum IDDCX_COLOR_SPACE : UINT
{
    /// Indicates that an IDDCX_COLOR_SPACE variable has not yet been assigned a meaningful value.
    /// </summary>
    IDDCX_COLOR_SPACE_UNINITIALIZED = 0,
    /// <summary>
    /// This is the standard definition for sRGB.
    /// </summary>
    IDDCX_COLOR_SPACE_G22_P709 = 1,
    /// <summary>
    /// This is the standard definition for HDR10.
    /// </summary>
    IDDCX_COLOR_SPACE_G2084_P2020 = 2,
    /// <summary>
    /// This is the standard definition for sRGB SDR WCG.
    /// </summary>
    IDDCX_COLOR_SPACE_G22_P709_WCG = 3,
};

enum IDDCX_METADATA2_VALID_FLAGS : UINT
{
    /// Indicates none of the optional fields in IDDCX_METADATA2 contain valid data and they should not be referenced.
    /// </summary>
    IDDCX_METADATA2_VALID_FLAGS_NONE = 0,
    /// <summary>
    /// When set, IDDCX_METADATA2::SystemBufferInfo contains valid data. This will be set by the OS in response to a driver setting
    /// IDARG_IN_RELEASEANDACQUIREBUFFER2::AcquireSystemMemoryBuffer to TRUE.
    /// </summary>
    IDDCX_METADATA2_VALID_FLAGS_SYSTEMBUFFERINFO = 0x1,
    /// <summary>
    /// When set, IDDCX_METADATA2::Hdr10FrameMetaData contains valid data.
    /// </summary>
    IDDCX_METADATA2_VALID_FLAGS_HDR10METADATA = 0x2,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_METADATA2_VALID_FLAGS);

enum IDDCX_HDR10_FRAME_METADATA_TYPE : UINT
{
    /// Indicates that an IDDCX_HDR10_FRAME_METADATA_TYPE variable has not yet been assigned a meaningful value.
    /// </summary>
    IDDCX_HDR10_FRAME_METADATA_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// When the OS sets type to default it means the data last sent to the driver in a call to EVT_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA for the
    /// monitor associated with this swapchain.
    /// </summary>
    IDDCX_HDR10_FRAME_METADATA_TYPE_DEFAULT = 1,
    /// <summary>
    /// When the OS sets type to unchanged it means whatever HDR meta data was used with the last frame should be used again, either default or new
    /// from an older frame.
    /// </summary>
    IDDCX_HDR10_FRAME_METADATA_TYPE_UNCHANGED = 2,
    /// <summary>
    /// The OS will set the type to new to tell the driver that the accompanying IDDCX_HDR10_FRAME_METADATA::NewMetaData contains valid data that a
    /// driver should use this meta data with this frame. The driver must also keep this meta data in case the next IDDCX_HDR10_FRAME_METADATA_TYPE
    /// is IDDCX_HDR10_FRAME_METADATA_TYPE_UNCHANGED. Note this meta data should not replace that which was sent in a call to EVT_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA.
    /// </summary>
    IDDCX_HDR10_FRAME_METADATA_TYPE_NEW = 3,
};

enum IDDCX_DISPLAYCONFIGPATH2_FLAGS : UINT
{
    /// Indicates that an IDDCX_DISPLAYCONFIGPATH2_FLAGS variable has not yet been assigned a meaningful value.
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS_UNINITIALIZED = 0x0,
    /// <summary>
    /// If set, the accompanying IDDCX_DISPLAYCONFIGPATH2::Mode field contains valid data.
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS_MODE_VALID = 0x1,
    /// <summary>
    /// If set, the accompanying IDDCX_DISPLAYCONFIGPATH2::MonitorScaleFactor field contains valid data.
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS_MONITOR_SCALE_FACTOR_VALID = 0x2,
    /// <summary>
    /// If set, the accompanying IDDCX_DISPLAYCONFIGPATH2::MonitorPhysicalSize field contains valid data.
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS_MONITOR_PHYSICAL_SIZE_VALID = 0x4,
    /// <summary>
    /// If set, the accompanying IDDCX_DISPLAYCONFIGPATH2::MonitorColorimetry field contains valid data.
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS_MONITOR_COLORIMETRY_VALID = 0x8,
    /// <summary>
    /// If set, the accompanying IDDCX_DISPLAYCONFIGPATH2::MonitorSdrWhiteLevel field contains valid data.
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS_MONITOR_SDRWHITELEVEL_VALID = 0x10,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_DISPLAYCONFIGPATH2_FLAGS);

enum IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE : UINT
{
    /// Indicates that an IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE variable has not yet been assigned a meaningful value.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE_UNINITIALIZED = 0,
    /// <summary>
    /// Allows a driver to indicate it wants to run in SDR mode even if the OS may wish to use HDR or SDR WCG.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE_SDR = 1,
    /// <summary>
    /// Allows a driver to indicate it wants to run in SDR WCG mode even if the OS may wish to use HDR or SDR.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE_SDRWCG = 2,
    /// <summary>
    /// Allows a driver to indicate it wants to run in HDR mode even if the OS may wish to use SDR or SDR WCG.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE_HDR10 = 3,
};

enum IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS : UINT
{
    /// Indicates that an IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS variable has not yet been assigned a meaningful value.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS_UNINITIALIZED = 0x0,
    /// <summary>
    /// Tells the OS the monitor supports the BT.2020 color space using a YCC signal format.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS_BT2020YCC = 0x1,
    /// <summary>
    /// Tells the OS the monitor supports the BT.2020 color space using an RGB signal format.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS_BT2020RGB = 0x2,
    /// <summary>
    /// Tells the OS the monitor supports the ST.2084 EOTF.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS_ST2084 = 0x4,
};
DEFINE_ENUM_FLAG_OPERATORS(IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS);



#pragma endregion

// Defines the function table used to indirectly call class extension functions.
typedef VOID (*PFN_IDD_CX)(VOID);
extern PFN_IDD_CX IddFunctions[];

// Forward-declare the driver globals structure, which contains system-defined per-driver data.
typedef struct IDD_DRIVER_GLOBALS IDD_DRIVER_GLOBALS, *PIDD_DRIVER_GLOBALS;

#include "IddCxFuncEnum.h"

#pragma region Forward Declarations

// Structures need to be referenced by the event callbacks
struct IDD_CX_CLIENT_CONFIG;
struct IDDCX_ENDPOINT_VERSION;
struct IDDCX_ENDPOINT_DIAGNOSTIC_INFO;
struct IDDCX_ADAPTER_CAPS;
struct IDARG_IN_ADAPTER_INIT_FINISHED;
struct IDARG_IN_ADAPTER_INIT;
struct IDARG_OUT_ADAPTER_INIT;
struct IDDCX_MONITOR_DESCRIPTION;
struct IDDCX_MONITOR_INFO;
struct IDARG_IN_MONITORCREATE;
struct IDARG_OUT_MONITORCREATE;
struct IDARG_OUT_MONITORARRIVAL;
struct IDDCX_MONITOR_MODE;
struct IDARG_IN_PARSEMONITORDESCRIPTION;
struct IDARG_OUT_PARSEMONITORDESCRIPTION;
struct IDARG_IN_GETDEFAULTDESCRIPTIONMODES;
struct IDARG_OUT_GETDEFAULTDESCRIPTIONMODES;
struct IDDCX_TARGET_MODE;
struct IDARG_IN_QUERYTARGETMODES;
struct IDARG_OUT_QUERYTARGETMODES;
struct IDARG_IN_UPDATEMODES;
struct IDARG_IN_MAXDISPLAYPIPELINERATE;
struct IDDCX_PATH;
struct IDARG_IN_COMMITMODES;
struct IDDCX_CURSOR_CAPS;
struct IDARG_IN_SETUP_HWCURSOR;
struct IDDCX_CURSOR_SHAPE_INFO;
struct IDARG_IN_QUERY_HWCURSOR;
struct IDARG_OUT_QUERY_HWCURSOR;
struct IDARG_IN_SETSWAPCHAIN;
struct IDDCX_METADATA;
struct IDARG_IN_SWAPCHAINSETDEVICE;
struct IDARG_OUT_RELEASEANDACQUIREBUFFER;
struct IDARG_IN_GETDIRTYRECTS;
struct IDARG_OUT_GETDIRTYRECTS;
struct IDDCX_MOVEREGION;
struct IDARG_IN_GETMOVEREGIONS;
struct IDARG_OUT_GETMOVEREGIONS;
struct IDDCX_FRAME_STATISTICS_STEP;
struct IDDCX_FRAME_STATISTICS;
struct IDARG_IN_REPORTFRAMESTATISTICS;
struct IDARG_IN_I2C_TRANSMIT;
struct IDARG_IN_SET_GAMMARAMP;
struct IDARG_IN_I2C_RECEIVE;
struct IDARG_IN_OPM_GET_CERTIFICATE_SIZE;
struct IDARG_OUT_OPM_GET_CERTIFICATE_SIZE;
struct IDARG_IN_OPM_GET_CERTIFICATE;
struct IDARG_IN_OPM_CREATE_PROTECTED_OUTPUT;
struct IDDCX_OPM_GET_RANDOM_NUMBER;
struct IDARG_OUT_OPM_GET_RANDOM_NUMBER;
struct IDDCX_OPM_ENCRYPTED_INITIALIZATION_PARAMETERS;
struct IDARG_IN_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS;
struct IDARG_IN_OPM_GET_INFOMATION;
struct IDDCX_OPM_GET_INFO_PARAMETERS;
struct IDDCX_OPM_REQUESTED_INFORMATION;
struct IDARG_OUT_OPM_GET_INFOMATION;
struct IDDCX_OPM_CONFIGURE_PARAMETERS;
struct IDARG_IN_OPM_CONFIGURE_PROTECTED_OUTPUT;
struct IDARG_OUT_GETVERSION;
struct IDARG_IN_REPORTCRITICALERROR;
struct IDARG_IN_SETSRMLIST;
struct IDARG_IN_GETSRMLISTVERSION;
struct IDARG_OUT_GETSRMLISTVERSION;
struct IDARG_IN_ADAPTERSETRENDERADAPTER;
struct IDDCX_DISPLAYCONFIGPATH;
struct IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE;
struct IDARG_OUT_MONITORGETPHYSICALSIZE;
struct IDDCX_SYSTEM_BUFFER_INFO;
struct IDARG_OUT_RELEASEANDACQUIRESYSTEMBUFFER;
struct IDARG_IN_SETREALTIMEGPUPRIORITY;
struct IDDCX_WIRE_BITS_PER_COMPONENT;
struct IDARG_IN_QUERYTARGET_INFO;
struct IDARG_OUT_QUERYTARGET_INFO;
struct IDDCX_HDR10_METADATA;
struct IDARG_IN_MONITOR_SET_DEFAULT_HDR_METADATA;
struct IDDCX_MONITOR_MODE2;
struct IDARG_IN_PARSEMONITORDESCRIPTION2;
struct IDDCX_TARGET_MODE2;
struct IDARG_IN_QUERYTARGETMODES2;
struct IDDCX_WIRE_FORMAT_INFO;
struct IDDCX_PATH2;
struct IDARG_IN_COMMITMODES2;
struct IDDCX_GAMMARAMP_RGB256x3x16;
struct IDDCX_RGB;
struct IDDCX_GAMMARAMP_3X4_COLORSPACE_TRANSFORM;
struct IDARG_IN_RELEASEANDACQUIREBUFFER2;
struct IDDCX_HDR10_FRAME_METADATA;
struct IDARG_OUT_RELEASEANDACQUIREBUFFER2;
struct IDARG_OUT_QUERY_HWCURSOR3;
struct IDDCX_DISPLAYCONFIG_MODE;
struct IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY;
struct IDDCX_DISPLAYCONFIGPATH2;
struct IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE2;
struct IDARG_IN_UPDATEMODES2;

#pragma endregion

#pragma region Driver Callback Definitions

#pragma region Device Callbacks

/// <summary>
/// Driver DDI function that is called by the OS when an IO control request needs processing by the driver.
/// </summary>
typedef
_Function_class_(EVT_IDD_CX_DEVICE_IO_CONTROL)
_IRQL_requires_same_
VOID
NTAPI
EVT_IDD_CX_DEVICE_IO_CONTROL(
    _In_
    WDFDEVICE Device,
    _In_
    WDFREQUEST Request,
    _In_
    size_t OutputBufferLength,
    _In_
    size_t InputBufferLength,
    _In_
    ULONG IoControlCode
    );

typedef EVT_IDD_CX_DEVICE_IO_CONTROL *PFN_IDD_CX_DEVICE_IO_CONTROL;

/// <summary>
///  A driver DDI function that OS calls to request the driver to parse a monitor description into a list of modes
/// the monitor supports
/// </summary>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION(
    _In_
    const IDARG_IN_PARSEMONITORDESCRIPTION* pInArgs,
    _Out_
    IDARG_OUT_PARSEMONITORDESCRIPTION* pOutArgs
    );

typedef EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION *PFN_IDD_CX_PARSE_MONITOR_DESCRIPTION;

#pragma endregion

#pragma region Adapter Callbacks

/// <summary>
/// A driver DDI that is called by the OS to inform the driver that the adapter initialization has completed. The
/// initialization may have failed, so the driver should check the parameters for the adapter status and handle
/// failures appropriately (possibly by reporting a device failure).
/// </summary>
typedef
_Function_class_(EVT_IDD_CX_ADAPTER_INIT_FINISHED)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_ADAPTER_INIT_FINISHED(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_ADAPTER_INIT_FINISHED* pInArgs
    );

typedef EVT_IDD_CX_ADAPTER_INIT_FINISHED *PFN_IDD_CX_ADAPTER_INIT_FINISHED;

/// <summary>
/// A driver DDI that is called by OS to inform the driver of a mode change for monitors on the adapter.
/// The OS always provides the IDDCX_PATH for every connected monitor even if it is not active and the OS
/// indicates which paths have changed.  If a path is marked not active then we expect that whole display pipeline for
/// that path to be powered off and no signal is sent to the monitor
///
/// NOTE : When a new path is committed the driver should program the display pipeline to display a black
/// image until the first frame is ready to be displayed(ie WDDM visibility should be off until
/// first frame is ready to be displayed and then the visibility should be turned on).
/// </summary>
/// <param name="hDriverAdapterContext">The handle the driver provides so the OS can reference the adapter when calling the driver</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_ADAPTER_COMMIT_MODES)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_ADAPTER_COMMIT_MODES(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_COMMITMODES* pInArgs
    );

typedef EVT_IDD_CX_ADAPTER_COMMIT_MODES *PFN_IDD_CX_ADAPTER_COMMIT_MODES;

#pragma endregion

#pragma region Monitor Callbacks

/// <summary>
/// A driver DDI function that OS calls to request the driver provide the default monitor mode list for the
/// specified monitor. This DDI is called when a monitor without a description is connected.
/// </summary>
/// <param name="MonitorObject">The monitor object that is having default modes generated</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// The driver must create at least one monitor mode for the monitor description.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_GETDEFAULTDESCRIPTIONMODES* pInArgs,
    _Out_
    IDARG_OUT_GETDEFAULTDESCRIPTIONMODES* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES *PFN_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES;

/// <summary>
/// A driver DDI function that OS calls to get a list of target modes supported by the driver for a monitor
/// connected to the endpoint.
/// </summary>
/// <param name="MonitorObject">The monitor object whose modes are being queried</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_QUERYTARGETMODES* pInArgs,
    _Out_
    IDARG_OUT_QUERYTARGETMODES* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES *PFN_IDD_CX_MONITOR_QUERY_TARGET_MODES;

/// <summary>
/// Driver DDI function that is called by OS inform the driver of a mode change for monitors on the adapter.
///
/// NOTE : The resolution of the surfaces in the swapchain will always be the same resolution as the target mode set and
///        format will be one of the formats supported by the driver but the format of each acquired buffer may
///        change frame to frame between the formats supported and the driver should check the format of each buffer acquired.
/// </summary>
/// <param name="hDriverAdapterContext">The handle the driver provides so the OS can reference the adapter when calling the driver</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_SETSWAPCHAIN* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN *PFN_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN;

/// <summary>
/// Driver DDI function that is called by OS inform the driver that a swapchain associated with a monitor is not
/// valid anymore
/// </summary>
/// <param name="MonitorObject">The monitor whose swap-chain is no longer valid.</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN(
    _In_
    IDDCX_MONITOR MonitorObject
    );

typedef EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN *PFN_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN;

/// <summary>
/// Driver DDI function that is called by OS to returns data received from an I2C device in a monitor
/// </summary>
/// <param name="MonitorObject">A handle to monitor object to send I2C data.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// The data is transmitted to an I2C device in the monitor that is connected to path specified by PathIdx
/// I2CTransmitDataToDisplay is responsible for signaling the I2C start condition, sending the I2C address, sending the
/// data in the buffer, checking for acknowledgments from the receiver, and signaling the stop condition.For details
/// about the I2C bus, see the I2C Bus Specification, published by Philips Semiconductors.The specification defines a
/// protocol for initiating I2C communication, reading and writing bytes over the I2C data line, and terminating I2C
/// communication.
///
/// I2CTransmitDataToDisplay is required to transmit data to an I2C device that has address 0x6E but is permitted to
/// refuse to transmit data to any I2C device that has a different address.
///
/// I2CTransmitDataToDisplay is permitted to block if another part of the display driver or graphics hardware is using
/// the specified monitor's I2C bus. It is also permitted to block if the display driver is using the I2C bus to send or
/// receive High-bandwidth Digital Content Protection (HDCP) data.
///
/// If the display adapter supports HDCP, the I2CTransmitDataToDisplay function must refuse to send data to an I2C device
/// if the device has an I2C address that is used by HDCP.
///
/// I2CTransmitDataToDisplay must never transmit data to an I2C device on the display adapter.That is, this function can
/// transmit data to an I2C device in a monitor that is connected to the display adapter, but not to an I2C device that
/// is on the display adapter itself.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_I2C_TRANSMIT)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_I2C_TRANSMIT(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_I2C_TRANSMIT* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_I2C_TRANSMIT *PFN_IDD_CX_MONITOR_I2C_TRANSMIT;

/// <summary>
/// Driver DDI function that is called by OS to returns data received from an I2C device in a monitor
/// </summary>
/// <param name="MonitorObject">A handle to monitor object to receive I2C data from.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// The data is received from an I2C device in the monitor that is connected to path specified by PathIdx
/// I2CReceiveDataFromDisplay function is responsible for signaling the I2C start condition, sending the I2C address,
/// receiving the data from the I2C device, sending acknowledgments, and signaling the stop condition.
/// For details about the I2C bus, see the I2C Bus Specification, published by Philips Semiconductors.
/// The specification defines a protocol for initiating I2C communication, reading and writing bytes over the I2C data
/// line, and terminating I2C communication. (This resource may not be available in some languages and countries.)
///
/// I2CReceiveDataFromDisplay is required to receive data from an I2C device that has address 0x6F but is
/// permitted to refuse to receive data from any I2C device that has a different address.
///
/// I2CReceiveDataFromDisplay is permitted to block if another part of the display driver or graphics hardware is
/// using the specified monitor's I2C bus. It is also permitted to block if the display driver is using the I2C
/// bus to send or receive High-bandwidth Digital Content Protection (HDCP) data.
///
/// If the display adapter supports HDCP, I2CReceiveDataFromDisplay must refuse to receive data from an I2C device if the
/// device has an I2C address that is used by HDCP.
///
/// I2CReceiveDataFromDisplay must never receive data from an I2C device on the display adapter.That is, this function
/// can receive data from an I2C device in a monitor that is connected to the display adapter, but not from an I2C
/// device that is on the display adapter itself.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_I2C_RECEIVE)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_I2C_RECEIVE(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_I2C_RECEIVE* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_I2C_RECEIVE *PFN_IDD_CX_MONITOR_I2C_RECEIVE;

/// <summary>
/// Driver DDI function that is called by OS to set a gamma ramp on the specified monitor
/// </summary>
/// <param name="MonitorObject">This is the context for the monitor this gamma call is intended for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// If the driver implements this DDI then this implies the driver support the gamma functionality
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_SET_GAMMARAMP* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP *PFN_IDD_CX_MONITOR_SET_GAMMA_RAMP;

/// <summary>
/// Driver DDI function that is called by OS to get the size of a OPM certificate
/// </summary>
/// <param name="AdapterObject">This is the context for the adapter this OPM call is intended for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_OPM_GET_CERTIFICATE_SIZE* pInArgs,
    _Out_
    IDARG_OUT_OPM_GET_CERTIFICATE_SIZE* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE *PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE;

/// <summary>
/// Driver DDI function that is called by OS to get a OPM certificate
/// </summary>
/// <param name="AdapterObject">This is the context for the adapter this OPM call is intended for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_OPM_GET_CERTIFICATE* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE *PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE;

/// <summary>
/// Driver DDI function that is called by OS to create a OPM protected output context
/// </summary>
/// <param name="MonitorObject">This is the context for the monitor this OPM context should be created on</param>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_CREATE_PROTECTED_OUTPUT* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT *PFN_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT;

/// <summary>
/// Driver DDI function that is called by OS get a OPM random number
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _Out_
    IDARG_OUT_OPM_GET_RANDOM_NUMBER* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER *PFN_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER;

/// <summary>
/// Driver DDI function that is called by OS to set signing key and sequence number
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS *PFN_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS;

/// <summary>
/// Driver DDI function that is called by OS to get OPM information
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_INFOMATION)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_GET_INFOMATION(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_GET_INFOMATION* pInArgs,
    _Out_
    IDARG_OUT_OPM_GET_INFOMATION* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_INFOMATION *PFN_IDD_CX_MONITOR_OPM_GET_INFOMATION;

/// <summary>
/// Driver DDI function that is called by OS to configure the protected output
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_CONFIGURE_PROTECTED_OUTPUT* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT *PFN_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT;

/// <summary>
/// Driver DDI function that is called by OS destroy the protected output context
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT(
    _In_
    IDDCX_OPMCTX OpmCxtObject
    );

typedef EVT_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT *PFN_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT;

/// <summary>
/// A driver DDI function that OS calls to query the physical size of a remote Edid'less monitor
/// </summary>
/// <param name="MonitorObject">This is the context for the monitor this OPM context should be created on</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the driver knows the physical size of the monitor is should fill in the pOutArgs and return 
/// STATUS_SUCCESS, in the event the driver does not know the physical size it should 
/// return STATUS_NO_DATA_DETECTED.
/// </returns>
/// <remarks>
/// This DDI is only called for remote drivers that do not provide a monitor descriptions for the 
/// specified monitor.  If a remote driver does specify a monitor description for a given monitor 
/// then the physical width and height will be taken from the description and this DDI will not be 
/// called for that monitor.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_GET_PHYSICAL_SIZE)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_GET_PHYSICAL_SIZE(
    _In_
    IDDCX_MONITOR MonitorObject,
    _Out_
    IDARG_OUT_MONITORGETPHYSICALSIZE* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_GET_PHYSICAL_SIZE *PFN_IDD_CX_MONITOR_GET_PHYSICAL_SIZE;

/// <summary>
/// EVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO is called by the OS to retrieve information about target capabilities.
/// </summary>
/// <param name="AdapterObject">The adapter object of the adapter being queried that was returned in a call to IddCxAdapterInitAsync</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the operation is successful, the callback function must return STATUS_SUCCESS, or another status value for which
/// NT_SUCCESS(status) equals TRUE. Otherwise, an appropriate NTSTATUS error code.
/// </returns>
/// <remarks>
/// After a driver calls IddCxAdapterInitAsync a call to the driver EVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO function will
/// be made for each possible monitor index from 0 to IDDCX_ADAPTER_CAPS::MaxMonitorsSupported - 1. It is important that
/// the information given for each id corresponds to the same id that could be later used in a call to IddCxMonitorCreate
/// in IDDCX_MONITOR_INFO::ConnectorIndex.
/// Note: Specifying IDDCX_BITS_PER_COMPONENT_NONE is valid however, to enable HDR, current Windows policies require
/// either the ability to send 10 or more bits per component to a monitor or alternatively the driver to support
/// dithering of more than 8 bits per component down to 8 bits per component. The ability to dither allows HDR to be
/// supported at 4K resolutions over HDMI 2.0.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    IDARG_IN_QUERYTARGET_INFO* pInArgs,
    _Out_
    IDARG_OUT_QUERYTARGET_INFO* pOutArgs
);

typedef EVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO *PFN_IDD_CX_ADAPTER_QUERY_TARGET_INFO;

/// <summary>
/// EVT_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA is called by the OS to provide the default HDR10 meta data
/// that should be sent to monitor when default meta data is specified when calling IddCxSwapChainReleaseAndAcquireBuffer2.
/// </summary>
/// <param name="MonitorObject">This is the OS context handle for this monitor returned by the IddCxMonitorCreate call</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the operation is successful, the callback function must return STATUS_SUCCESS, or another status value for which
/// NT_SUCCESS(status) equals TRUE. Otherwise, an appropriate NTSTATUS error code.
/// </returns>
/// <remarks>
/// The OS will call the driver for any monitor that supports HDR to tell the driver what the default HDR meta data to be
/// used is, if the driver sets the IDDCX_ADAPTER_FLAGS_CAN_PROCESS_FP16 flag. This will be done after IddCxMonitorCreate
/// is called and before any calls to EVT_IDD_CX_ADAPTER_COMMIT_MODES2. The driver should use this data whenever
/// IDDCX_HDRMETADATA_TYPE_DEFAULT is specified as the meta data type in the IDDCX_METADATA2 returned when calling
/// IddCxSwapChainReleaseAndAcquireBuffer2. The OS may call the driver to update this default at any time.
/// Note: Remote drivers will not be sent HDR meta data, HDR meta data from the client should be used at all times.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_MONITOR_SET_DEFAULT_HDR_METADATA *pInArgs
);

typedef EVT_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA *PFN_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA;

/// <summary>
/// EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION2 is called by the OS to request the driver to parse a monitor description into
/// a list of modes that the monitor supports, this new callback allows the driver to report extra information needed
/// for HDR10 or WCG monitor modes.
/// </summary>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the operation is successful, the callback function must return STATUS_SUCCESS, or another status value for which
/// NT_SUCCESS(status) equals TRUE. Otherwise, an appropriate NTSTATUS error code.
/// </returns>
/// <remarks>
/// A 1.10 or later Indirect Display driver that supports HDR must expose this new function to report modes, which will
/// be called in place of EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION to allow the driver to return more information about each
/// mode. Setting IDDCX_WIRE_BITS_PER_COMPONENT::BitsPerComponent.Rgb to IDDCX_BITS_PER_COMPONENT_8 is equivalent to
/// creating a mode via the old functions. New drivers that do not support HDR can continue to report only the existing
/// function.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION2)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION2(
    _In_
    const IDARG_IN_PARSEMONITORDESCRIPTION2 *pInArgs,
    _Out_
    IDARG_OUT_PARSEMONITORDESCRIPTION *pOutArgs
);

typedef EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION2 *PFN_IDD_CX_PARSE_MONITOR_DESCRIPTION2;

/// <summary>
/// EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES2 is called by the OS to get a list of target modes supported by the driver for
/// a monitor connected to the endpoint. This new callback provides the ability for the driver to report extra
/// information needed for HDR10 or WCG target modes.
/// </summary>
/// <param name="MonitorObject">This is the OS context handle for this monitor returned by the IddCxMonitorCreate call</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the operation is successful, the callback function must return STATUS_SUCCESS, or another status value for which
/// NT_SUCCESS(status) equals TRUE. Otherwise, an appropriate NTSTATUS error code.
/// </returns>
/// <remarks>
/// This function is similar to EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION2 in that it allows drivers to report the same extra
/// mode information. This is required to support HDR, otherwise drivers are free to only expose the existing function.
/// Note: The OS will infer that modes support SDR WCG or HDR based on the target info previously provided by the driver in
/// a call to EVT_IDD_CX_ADAPTER_QUERY_TARGET_INFO.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES2)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES2(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_QUERYTARGETMODES2* pInArgs,
    _Out_
    IDARG_OUT_QUERYTARGETMODES* pOutArgs
);

typedef EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES2 *PFN_IDD_CX_MONITOR_QUERY_TARGET_MODES2;

/// <summary>
/// EVT_IDD_CX_ADAPTER_COMMIT_MODES2 is called by the OS to inform the driver of a mode change for monitors on the adapter.
/// </summary>
/// <param name="AdapterObject">The adapter object of the adapter being queried that was returned in a call to IddCxAdapterInitAsync</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the operation is successful, the callback function must return STATUS_SUCCESS, or another status value for which
/// NT_SUCCESS(status) equals TRUE. Otherwise, an appropriate NTSTATUS error code.
/// </returns>
/// <remarks>
/// When modes are committed for monitors, 1.10 drivers that support HDR or WCG are called via this new function and told
/// the color space and bits per component to be used on the physical monitor connection. These values are based on the
/// target capabilities and mode parameters previously reported by the driver. Reporting adapter support for FP16 but not
/// exposing this function is an error.
/// Note: The color space specified in a committed mode does not specify the surface format used for every surface in a
/// swapchain, the surface provided in IDDCX_METADATA2 must still be queried.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_ADAPTER_COMMIT_MODES2)
_IRQL_requires_same_
NTSTATUS
NTAPI
EVT_IDD_CX_ADAPTER_COMMIT_MODES2(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_COMMITMODES2 *pInArgs
);

typedef EVT_IDD_CX_ADAPTER_COMMIT_MODES2 *PFN_IDD_CX_ADAPTER_COMMIT_MODES2;

#pragma endregion

#pragma endregion

#pragma region Structure Definitions

/// <summary>
/// Holds per-driver Indirect Display information. Reserved for use by the system.
/// </summary>
typedef struct IDD_DRIVER_GLOBALS
{
    ULONG Reserved;
} IDD_DRIVER_GLOBALS, *PIDD_DRIVER_GLOBALS;

/// <summary>
/// Contains information and callbacks for WDFDEVICE intitialization using the Indirect Display class extension.
/// </summary>
struct IDD_CX_CLIENT_CONFIG
{
    /// <summary>
    /// The total size of the structure.
    /// </summary>
    ULONG Size;

    PFN_IDD_CX_DEVICE_IO_CONTROL EvtIddCxDeviceIoControl;
    PFN_IDD_CX_PARSE_MONITOR_DESCRIPTION EvtIddCxParseMonitorDescription;

    PFN_IDD_CX_ADAPTER_INIT_FINISHED EvtIddCxAdapterInitFinished;
    PFN_IDD_CX_ADAPTER_COMMIT_MODES EvtIddCxAdapterCommitModes;

    PFN_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES EvtIddCxMonitorGetDefaultDescriptionModes;
    PFN_IDD_CX_MONITOR_QUERY_TARGET_MODES EvtIddCxMonitorQueryTargetModes;
    PFN_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN EvtIddCxMonitorAssignSwapChain;
    PFN_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN EvtIddCxMonitorUnassignSwapChain;
    PFN_IDD_CX_MONITOR_I2C_TRANSMIT EvtIddCxMonitorI2CTransmit;
    PFN_IDD_CX_MONITOR_I2C_RECEIVE EvtIddCxMonitorI2CReceive;
    PFN_IDD_CX_MONITOR_SET_GAMMA_RAMP EvtIddCxMonitorSetGammaRamp;

    PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE EvtIddCxMonitorOPMGetCertificateSize;
    PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE EvtIddCxMonitorOPMGetCertificate;
    PFN_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT EvtIddCxMonitorOPMCreateProtectedOutput;
    PFN_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER EvtIddCxMonitorOPMGetRandomNumber;
    PFN_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS EvtIddCxMonitorOPMSetSigningKeyAndSequenceNumbers;
    PFN_IDD_CX_MONITOR_OPM_GET_INFOMATION EvtIddCxMonitorOPMGetInformation;
    PFN_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT EvtIddCxMonitorOPMConfigureProtectedOutput;
    PFN_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT EvtIddCxMonitorOPMDestroyProtectedOutput;

    PFN_IDD_CX_MONITOR_GET_PHYSICAL_SIZE EvtIddCxMonitorGetPhysicalSize;

    PFN_IDD_CX_PARSE_MONITOR_DESCRIPTION2 EvtIddCxParseMonitorDescription2;
    PFN_IDD_CX_ADAPTER_QUERY_TARGET_INFO EvtIddCxAdapterQueryTargetInfo;
    PFN_IDD_CX_ADAPTER_COMMIT_MODES2 EvtIddCxAdapterCommitModes2;
    PFN_IDD_CX_MONITOR_SET_DEFAULT_HDR_METADATA EvtIddCxMonitorSetDefaultHdrMetaData;
    PFN_IDD_CX_MONITOR_QUERY_TARGET_MODES2 EvtIddCxMonitorQueryTargetModes2;
};

/// <summary>
/// Structure used to describe a version
/// </summary>
struct IDDCX_ENDPOINT_VERSION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The major version defined by the driver
    /// </summary>
    UINT MajorVer;

    /// <summary>
    /// The minor version defined by the driver
    /// </summary>
    UINT MinorVer;

    /// <summary>
    /// The build number defined by the driver
    /// </summary>
    UINT Build;

    /// <summary>
    /// The SKU type defined by the driver
    /// </summary>
    UINT64 SKU;
};

/// <summary>
/// Structure used to provide diagnostics information about an endpoint
/// </summary>
struct IDDCX_ENDPOINT_DIAGNOSTIC_INFO
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Describes the type of link the video data is being transmitted over
    /// </summary>
    IDDCX_TRANSMISSION_TYPE TransmissionType;

    /// <summary>
    /// The friendly name of the endpoint if one exists, this is applicable if the user can give the device
    /// a name, should be NULL if friendly name does not exist
    /// </summary>
    PCWSTR pEndPointFriendlyName;

    /// <summary>
    /// The model name of the endpoint, must be a non - empty string
    /// </summary>
    PCWSTR pEndPointModelName;

    /// <summary>
    /// The manufacture name of the endpoint, must be a non - empty string
    /// </summary>
    PCWSTR pEndPointManufacturerName;

    /// <summary>
    /// Pointer to version info for the endpoint hardware
    /// </summary>
    IDDCX_ENDPOINT_VERSION* pHardwareVersion;

    /// <summary>
    /// Pointer to version info for the endpoint hardware
    /// </summary>
    IDDCX_ENDPOINT_VERSION* pFirmwareVersion;

    /// <summary>
    /// Indicates how gamma is implemented
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION GammaSupport;
};

/// <summary>
/// Used to define the capabilities of an adapter
/// </summary>
struct IDDCX_ADAPTER_CAPS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    IDDCX_ADAPTER_FLAGS Flags;

    /// <summary>
    /// This value represents the total display bandwidth for the adapter, each mode the driver reports to
    /// the OS also has a display pipeline rate associated with it and the OS will ensure that the combined
    /// display pipeline rate of all the active modes will never exceed this value. The units the driver uses
    /// is up to the driver.
    /// </summary>
    UINT64 MaxDisplayPipelineRate;

    /// <summary>
    /// Indicates the maximum number of monitors that can be connected at the same time
    /// </summary>
    UINT MaxMonitorsSupported;

    /// <summary>
    /// Endpoint diagnostics information, none of this is used for runtime OS decision but used for telemetry
    /// </summary>
    IDDCX_ENDPOINT_DIAGNOSTIC_INFO EndPointDiagnostics;

    /// <summary>
    /// The number of frames to request after the desktop goes idle if the driver's encoder requires multiple frames
    /// to continue improving quality.
    /// </summary>
    UINT StaticDesktopReencodeFrameCount;
};

struct IDARG_IN_ADAPTER_INIT
{
    /// <summary>
    /// The device that will be hosting this WDDM adapter object.
    /// </summary>
    WDFDEVICE WdfDevice;

    /// <summary>
    /// [in] Adapter capabilities
    /// </summary>
    IDDCX_ADAPTER_CAPS* pCaps;

    /// <summary>
    /// [in, optional] Object attributes that are used to initialize the WDF adapter object.
    /// </summary>
    PWDF_OBJECT_ATTRIBUTES ObjectAttributes;
};

struct IDARG_OUT_ADAPTER_INIT
{
    /// <summary>
    /// [out] Handle to the adapter that the driver can use to identify this adapter when calling OS functions.
    /// </summary>
    IDDCX_ADAPTER AdapterObject;
};

struct IDARG_IN_ADAPTER_INIT_FINISHED
{
    NTSTATUS AdapterInitStatus;
};

struct IDDCX_MONITOR_DESCRIPTION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Type of this monitor description
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION_TYPE Type;

    /// <summary>
    /// The size of the monitor description data
    /// </summary>
    UINT DataSize;

    /// <summary>
    /// Pointer to the monitor description data
    /// Depending on the Type it can be either EDID or DisplayID + EDID
    /// Reference IDDCX_MONITOR_DESCRIPTION_TYPE for more information
    /// </summary>
    _Field_size_full_(DataSize) PVOID pData;

    /// <remarks>
    /// If the monitor does not have a description the driver should set DataSize
    /// to zero and pData to NULL.
    /// </remarks>  
};

/// <summary>
/// Used to specify information about a monitor
/// </summary>
struct IDDCX_MONITOR_INFO
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The is the monitor connector type of the monitor
    /// </summary>
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY MonitorType;

    /// <summary>
    /// This is a zero based unique identifier for this connector, it should be unique for this adapter and the value should
    /// not change for this connector across system reboot or driver upgrade.
    /// The value has to be between 0 and (IDDCX_ADAPTER_CAPS.MaxMonitorsSupported-1)
    /// </summary>
    UINT ConnectorIndex;

    /// <summary>
    /// Monitor description for the monitor
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// Container Id of the monitor being connected, if any device is also inside the monitor (eg audio, touch etc) then
    /// those device should all have the same container id.
    /// </summary>
    GUID MonitorContainerId;
};

struct IDARG_IN_MONITORCREATE
{
    PWDF_OBJECT_ATTRIBUTES ObjectAttributes;

    /// <summary>
    /// [in] Pointer to the information about this monitor
    /// </summary>
    IDDCX_MONITOR_INFO* pMonitorInfo;
};

struct IDARG_OUT_MONITORCREATE
{
    /// <summary>
    /// [out] Handle the driver can use to identify this monitor when calling OS functions
    /// </summary>
    IDDCX_MONITOR MonitorObject;
};

struct IDARG_OUT_MONITORARRIVAL
{
    /// <summary>
    /// Luid of the adapter where this monitor is exposed to the OS
    /// NOTE : There are no API/DDI calls the driver can do with this info it's only use is to pass to companion
    /// applications so they can identify the monitor they control
    /// </summary>
    LUID OsAdapterLuid;

    /// <summary>
    /// DMM VidPn target id of the target this monitor is exposed to the OS
    /// NOTE : There are no API/DDI calls the driver can do with this info it's only use is to pass to companion
    /// applications so they can identify the monitor they control
    /// NOTE : Although this value is related to the IDDCX_MONITOR_INFO.ConnectorIndex passed by the driver
    /// the OS will perform internal mapping between the two that will change is future release so the driver should not take
    /// any dependences on this mapping and hence should use OsAdapterLuid & OsTargetId and not IDDCX_MONITOR_INFO.ConnectorIndex
    /// </summary>
    UINT OsTargetId;
};

struct IDDCX_MONITOR_MODE
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Where the driver derived this mode from
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN Origin;

    /// <summary>
    /// This is the details of the Monitor mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// </summary>
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO MonitorVideoSignalInfo;
};

struct IDARG_IN_PARSEMONITORDESCRIPTION
{
    /// <summary>
    /// [in] Monitor description the driver should decode
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// [in] The number of monitor modes the pMonitorModes buffer being passed into the driver can hold.
    /// A value of zero indicates that the driver should not copy the monitor mode list
    /// into the provide buffer but should set the output buffer size to the size required
    /// </summary>
    UINT MonitorModeBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer that driver should copy the monitor modes to if the value is non-NULL.
    /// If value is NULL then driver should not copy any data and should just set the value
    /// IDARG_OUT_PARSEMONITORDESCRIPTION.MonitorModeBufferOutputCount to indicate the size of buffer
    /// required to store the modes
    /// </summary>
    _Field_size_opt_(MonitorModeBufferInputCount) IDDCX_MONITOR_MODE* pMonitorModes;
};

#define NO_PREFERRED_MODE 0xffffffff

struct IDARG_OUT_PARSEMONITORDESCRIPTION
{
    /// <summary>
    /// [out] If IDARG_IN_PARSEMONITORDESCRIPTION.pMonitorModes was NULL then driver should
    /// set this to the number of monitor modes the driver would generate for the specified monitor
    /// description.
    /// If IDARG_IN_PARSEMONITORDESCRIPTION.pMonitorModes was non-NULL then this is the count of the
    /// monitor modes that the driver copied to that buffer
    /// </summary>
    UINT MonitorModeBufferOutputCount;

    /// <summary>
    /// [out] Index into the pMonitorModes array of the preferred mode monitor mode, a value of NO_PREFERRED_MODE
    /// indicates that there is no preferred monitor mode
    /// </summary>
    UINT PreferredMonitorModeIdx;
};

struct IDARG_IN_GETDEFAULTDESCRIPTIONMODES
{
    /// <summary>
    /// [in] The number of monitor modes the pDefaultsMonitorModes buffer being passed into the driver can hold.
    /// A value of zero indicates that the driver should not copy the monitor mode list
    /// into the provide buffer but should set the output buffer size to the size required
    /// </summary>
    UINT DefaultMonitorModeBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer that driver should copy the monitor modes to if the value is non-NULL.
    /// If value is NULL then driver should not copy any data and should just set the value
    /// IDARG_OUT_GETDEFAULTDESCRIPTIONMODES.DefaultMonitorModeBufferOutputCount to indicate the size of buffer
    /// required to store the modes
    /// </summary>
    _Field_size_opt_(DefaultMonitorModeBufferInputCount) IDDCX_MONITOR_MODE* pDefaultMonitorModes;
};

struct IDARG_OUT_GETDEFAULTDESCRIPTIONMODES
{
    /// <summary>
    /// [out] If IDARG_IN_PARSEMONITORDESCRIPTION.pDefaultMonitorModes was NULL then driver should
    /// set this to the number of monitor modes the driver would generate for the specified monitor
    /// description.
    /// If IDARG_IN_PARSEMONITORDESCRIPTION.pDefaultMonitorModes was non-NULL then this is the count of the
    /// monitor modes that the driver copied to that buffer
    /// </summary>
    UINT DefaultMonitorModeBufferOutputCount;

    /// <summary>
    /// [out] Index into the pMonitorModes array of the preferred mode monitor mode, a value of NO_PREFERRED_MODE
    /// indicates that there is no preferred monitor mode
    /// </summary>
    UINT PreferredMonitorModeIdx;
};

/// <summary>
/// Used to describe a target mode
/// </summary>
struct IDDCX_TARGET_MODE
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// This is the details of the target mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// NOTE : DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq is the Vsync rate between the Indirect Display device and the
    /// connected monitor.  DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider is used to
    /// calculate the rate at which the OS will update the desktop image.
    /// The desktop update rate will calculate be :
    ///    DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq / DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider
    /// DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider cannot be zero
    /// </summary>
    DISPLAYCONFIG_TARGET_MODE TargetVideoSignalInfo;

    /// <summary>
    /// This is the display pipeline bandwidth required for this mode.
    /// </summary>
    UINT64 RequiredBandwidth;
};

struct IDARG_IN_QUERYTARGETMODES
{
    /// <summary>
    /// [in] The monitor description, note this may not be the monitor description the driver originally
    /// provided in the monitor arrival call, the driver needs to use this monitor description
    /// when processing this DDI. This allows for monitor description to be updated by OS.
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// [in] The number of target modes the pTargetModes buffer be passed to the driver can hold.
    /// If the value is zero then the driver should not copy the target mode list to pTargetModes
    /// </summary>
    UINT TargetModeBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer driver should copy the target modes it supports for this monitor
    /// </summary>
    _Field_size_(TargetModeBufferInputCount) IDDCX_TARGET_MODE* pTargetModes;
};

struct IDARG_OUT_QUERYTARGETMODES
{
    /// <summary>
    /// [out] Driver should set this to the number of target modes the driver copied to the buffer
    /// if the OS provided one otherwise the number of target modes it would have copied if the OS
    /// had provided a buffer
    /// </summary>
    UINT TargetModeBufferOutputCount;
};

struct IDARG_IN_UPDATEMODES
{
    /// <summary>
    /// Indicates the reason why the driver is updating the modes
    /// </summary>
    IDDCX_UPDATE_REASON Reason;

    /// <summary>
    /// [in] Number of target modes in the pTargetModes buffer.  This cannot be zero
    /// </summary>
    UINT TargetModeCount;

    /// <summary>
    /// [in] Pointer to buffer driver should copy the target modes it supports for this monitor
    /// </summary>
    _Field_size_(TargetModeCount) IDDCX_TARGET_MODE* pTargetModes;
};

struct IDARG_IN_MAXDISPLAYPIPELINERATE
{
    /// <summary>
    /// Indicates the reason why the driver is updating the rate
    /// </summary>
    IDDCX_UPDATE_REASON Reason;

    /// <summary>
    /// This is the new value for IDDCX_ADAPTER_CAPS.MaxDisplayPipelineRate
    /// </summary>
    UINT64 MaxDisplayPipelineRate;
};

/// <summary>
/// Used to describe the mode that should be set on a given monitor
/// </summary>
struct IDDCX_PATH
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The handle the driver provides to identify the monitor this path is targeted at
    /// </summary>
    IDDCX_MONITOR MonitorObject;

    /// <summary>
    /// Contains flags for this path, like the path's active state and whether it changed.
    /// </summary>
    IDDCX_PATH_FLAGS Flags;

    /// <summary>
    /// This is the details of the target mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// NOTE : DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq is the Vsync rate between the Indirect Display device and the
    /// connected monitor.  DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider is used to
    /// calculate the rate at which the OS will update the desktop image.
    /// The desktop update rate will calculate be :
    ///    DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq / DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider
    /// DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider cannot be zero
    /// </summary>
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO TargetVideoSignalInfo;
};

struct IDARG_IN_COMMITMODES
{
    /// <summary>
    /// [in] The number of paths in the pPaths array
    /// </summary>
    UINT PathCount;

    /// <summary>
    /// [in] Point to the array of paths to be committed
    /// </summary>
    _Field_size_(PathCount) IDDCX_PATH* pPaths;
};

/// <summary>
/// Structure used to describe the cursor capabilities for a given path.
/// </summary>
struct IDDCX_CURSOR_CAPS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Indicates what level of support the driver has for XOR masks in the 32-bit masked color cursor format.
    /// NOTE : The OS will first convert any monochrome cursor to a color mask cursor.
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT ColorXorCursorSupport;

    /// <summary>
    /// Indicates if the adapter supports the 32-bit alpha cursor format. Most cursors are alpha format.
    /// </summary>
    BOOL AlphaCursorSupport;

    /// <summary>
    /// The maximum width supported for all supported cursor types
    /// </summary>
    UINT MaxX;

    /// <summary>
    /// The maximum height support for all cursor types
    /// </summary>
    UINT MaxY;
};

struct IDARG_IN_SETUP_HWCURSOR
{
    /// <summary>
    /// [in] Cursor information for this path
    /// </summary>
    IDDCX_CURSOR_CAPS CursorInfo;

    /// <summary>
    /// [in] An event handle that will be triggered when new cursor data is available
    /// </summary>
    HANDLE hNewCursorDataAvailable;
};

/// <summary>
/// Describes the cursor shape
/// </summary>
struct IDDCX_CURSOR_SHAPE_INFO
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Unique id for the current cursor image, this is incremented each time a cursor image is set (even if that image has been set before).
    /// This is used to check if the current cursor image the driver has cached has changed and cannot be used in any way to allow caching
    /// for animated cursor sequences.
    /// </summary>
    UINT ShapeId;

    /// <summary>
    /// Indicates the type of cursor data written to the cursor shape buffer
    /// </summary>
    IDDCX_CURSOR_SHAPE_TYPE CursorType;

    /// <summary>
    /// Width in pixels of the cursor shape written to the shape buffer
    /// </summary>
    UINT Width;

    /// <summary>
    /// Height in pixels of the cursor shape written to the shape buffer
    /// </summary>
    UINT Height;

    /// <summary>
    /// Pitch in bytes of the cursor shape written to the shape buffer
    /// </summary>
    UINT Pitch;

    /// <summary>
    /// X position of the cursor hotspot relative to the top-left of the cursor
    /// </summary>
    UINT XHot;

    /// <summary>
    /// Y position of the cursor hotspot relative to the top-left of the cursor
    /// </summary>
    UINT YHot;
};

struct IDARG_IN_QUERY_HWCURSOR
{
    /// <summary>
    /// [in] The shape id of the last cursor shape the driver received for this monitor, this is compared against the
    /// latest shape the OS has and the new shape is only copied to the buffer it OS version has been updated since
    /// last image driver received
    /// </summary>
    DWORD LastShapeId;

    /// <summary>
    /// [in] Size of the cursor shape buffer pShapeBuffer
    /// </summary>
    UINT ShapeBufferSizeInBytes;

    /// <summary>
    /// [out] Buffer provided by driver that the OS will copy any new cursor image data into
    /// </summary>
    _Field_size_bytes_(ShapeBufferSizeInBytes) PBYTE pShapeBuffer;
};

struct IDARG_OUT_QUERY_HWCURSOR
{
    /// <summary>
    /// [out] Indicates if the cursor is visible or not.
    /// </summary>
    BOOL IsCursorVisible;

    /// <summary>
    /// [out] If the cursor is visible then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT X;

    /// <summary>
    /// [out] If the cursor is visible then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT Y;

    /// <summary>
    /// [out] Indicates if the cursor shape has been updated since the last time the driver called, if it has been updated
    /// then the OS updated the CursorShapeInfo structure and also copied the new cursor image data into the
    /// IDARG_IN_QUERY_HWCURSOR.pShapeBuffer buffer
    /// </summary>
    BOOL IsCursorShapeUpdated;

    /// <summary>
    /// [out] If cursor visible then OS will copy the current cursor info into this buffer, if cursor is not visible then
    /// OS will zero this structure
    /// </summary>
    IDDCX_CURSOR_SHAPE_INFO CursorShapeInfo;
};

struct IDARG_OUT_QUERY_HWCURSOR2
{
    /// <summary>
    /// [out] Indicates if the cursor is visible or not.  
    /// </summary>
    BOOL IsCursorVisible;

    /// <summary>
    /// [out] If the cursor is visible then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// Only valid if PositionValid is TRUE
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT X;

    /// <summary>
    /// [out] If the cursor is visible then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// Only valid if PositionValid is TRUE
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT Y;

    /// <summary>
    /// [out] Indicates if the cursor shape has been updated since the last time the driver called, if it has been updated
    /// then the OS updated the CursorShapeInfo structure and also copied the new cursor image data into the
    /// IDARG_IN_QUERY_HWCURSOR.pShapeBuffer buffer
    /// </summary>
    BOOL IsCursorShapeUpdated;

    /// <summary>
    /// [out] If cursor visible then OS will copy the current cursor info into this buffer, if cursor is not visible then
    /// OS will zero this structure
    /// </summary>
    IDDCX_CURSOR_SHAPE_INFO CursorShapeInfo;

    /// <summary>
    /// [out] Indicates if the X, Y and PositionId fields in this structure are valid or not
    /// </summary>
    BOOL PositionValid;

    /// <summary>
    /// [out] The position id of the last cursor position that the OS received for this monitor, the driver can 
    /// compare this to the last cursor position that it processed to know it should process a new position update.
    /// Note that there are cases where the position values may not changed but position id value has changed, in this
    /// case the driver should process the position as if it was a new move.
    /// PositionId is not updated if IsCursorVisible changes
    /// Only valid if PositionValid is TRUE
    /// </summary>
    UINT PositionId;
};

struct IDARG_IN_SETSWAPCHAIN
{
    /// <summary>
    /// [in] Handle to indirect swapchain that will be used to pass the desktop image to the driver
    /// for processing, transmission and display
    /// </summary>
    IDDCX_SWAPCHAIN hSwapChain;

    /// <summary>
    /// [in] Handle to auto reset event that is signaled when new image to encode is ready
    /// </summary>
    HANDLE hNextSurfaceAvailable;

    /// <summary>
    /// [In] Luid of the adapter were the desktop image was rendered
    /// </summary>
    LUID RenderAdapterLuid;
};

/// <summary>
/// Per frame meta-data
/// </summary>
struct IDDCX_METADATA
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Presentation frame number of this surface, if the frame number is the same as the previous frame then
    /// that indicates that there has not been any image updates from the previous frame and is an opportunity
    /// for the driver to re-encode the desktop image again to increase the visual quality.
    /// Once there are no more updates the OS will present the same frame IDDCX_ADAPTER_CAPS.StaticDesktopReencodeFrameCount
    /// times (a presentation internals) and then stop presenting until the next update
    /// </summary>
    UINT PresentationFrameNumber;

    /// <summary>
    /// Number of dirty rects for this frame, call GetDirtyRects() to get the dirty rects
    /// NOTE : A zero DirtyRectCount and MoveRegionCount value indicates there were no desktop updates and the
    /// PresentationFrameNumber is the same as last frame
    /// </summary>
    UINT DirtyRectCount;

    /// <summary>
    /// Number of move regions in this frame, call GetMoveRegions() to get the move regions
    /// NOTE : A zero DirtyRectCount and MoveRegionCount value indicates there were no desktop updates and the
    /// PresentationFrameNumber is the same as last frame
    /// </summary>
    UINT MoveRegionCount;

    /// <summary>
    /// Indicates if the provided surface is hardware protected or not
    /// </summary>
    BOOL HwProtectedSurface;

    /// <summary>
    /// System QPC time of when this surface should be displayed on the indirect display monitor
    /// </summary>
    UINT64 PresentDisplayQPCTime;

    /// <summary>
    /// DX surface that contains the image to encode and transmit.
    /// The driver can use this DX surface anytime until ReleaseAndAcquire is called again
    /// NOTE : This surface is always a A8R8G8B8 formated surface
    /// </summary>
    IDXGIResource* pSurface;
};

struct IDARG_IN_SWAPCHAINSETDEVICE
{
    /// <summary>
    /// The DXGI device used to process swap-chain frames.
    /// </summary>
    IDXGIDevice* pDevice;
};

struct IDARG_OUT_RELEASEANDACQUIREBUFFER
{
    /// <summary>
    /// [out] Per-frame metadata and frame information
    /// </summary>
    IDDCX_METADATA MetaData;
};

struct IDARG_IN_GETDIRTYRECTS
{
    /// <summary>
    /// [in] Number of dirty rects in the pDirtyRects array
    /// </summary>
    UINT DirtyRectInCount;

    /// <summary>
    /// [out] Pointer to the buffer where the OS can copy the dirty rects that indicate which parts of the surface have been
    /// changed since the last present.
    /// </summary>
    _Field_size_full_(DirtyRectInCount) RECT* pDirtyRects;
};


struct IDARG_OUT_GETDIRTYRECTS
{
    /// <summary>
    /// [out] Number of dirty rects the OS copied into the pDirtyRects array
    /// </summary>
    UINT DirtyRectOutCount;
};

/// <summary>
/// Describes a move region within a surface
/// </summary>
struct IDDCX_MOVEREGION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The location within the surface of the top left of the source rect, the source rect size is the same as the
    /// destination rect size
    /// </summary>
    POINT SourcePoint;

    /// <summary>
    /// Defines the destination rect of the move
    /// </summary>
    RECT DestRect;
};

struct IDARG_IN_GETMOVEREGIONS
{
    /// <summary>
    /// [in] Number of move regions in the pMoveRegions array
    /// </summary>
    UINT MoveRegionInCount;

    /// <summary>
    /// [out] Pointer to the buffer where the OS can copy the move regions
    /// </summary>
    _Field_size_full_(MoveRegionInCount) IDDCX_MOVEREGION* pMoveRegions;
};


struct IDARG_OUT_GETMOVEREGIONS
{
    /// <summary>
    /// [out] Number of move regions the OS copied into the pMoveRegions array
    /// </summary>
    UINT MoveRegionOutCount;
};

/// <summary>
/// Defines a single step of the frame processing
/// </summary>
struct IDDCX_FRAME_STATISTICS_STEP
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The type of frame processing step
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE Type;

    /// <summary>
    /// Provides the system QPC time of the step
    /// </summary>
    UINT64 QpcTime;

    /// <summary>
    /// When driver defined processing part is used then driver can store additional data here
    /// </summary>
    UINT32 Data[2];
};

/// <summary>
/// Holds the frame processing statics for a whole frame
/// </summary>
struct IDDCX_FRAME_STATISTICS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The frame number provided in the ReleaseAndAcquireBuffer call
    /// </summary>
    UINT PresentationFrameNumber;

    /// <summary>
    /// Indicates the overall status of processing this frame
    /// </summary>
    IDDCX_FRAME_STATUS FrameStatus;

    /// <summary>
    /// Zero based number to indicates the number of times the same frame has been encoded and sent.
    /// Re-encodes can be the result of the OS providing the sane frame (and frame number) to the driver to
    /// encode or the driver having to re-encode outside of the normal OS presentation to satisfy the
    /// protocol
    /// </summary>
    UINT ReEncodeNumber;

    /// <summary>
    /// Indicates the number of slices the driver processes the frame in, if slices are not used
    /// then this should be set to the value one
    /// </summary>
    UINT FrameSliceTotal;

    /// <summary>
    /// Indicates the zero based slice number being reported, if slicing is not supported then the driver
    /// should always set this to the value zero
    /// </summary>
    UINT CurrentSlice;

    /// <summary>
    /// System Qpc time the driver acquired the buffer from the OS
    /// </summary>
    UINT64 FrameAcquireQpcTime;

    /// <summary>
    /// The size of the frame step array pointed to by pFrameParts
    /// </summary>
    UINT FrameProcessingStepsCount;

    /// <summary>
    /// Array of frame processing steps the driver performed
    /// </summary>
    _Field_size_(FrameProcessingStepsCount) IDDCX_FRAME_STATISTICS_STEP* pFrameProcessingStep;

    /// <summary>
    /// Marks the time when the driver started transmission for this slice to the device
    /// NOTE : This marks the time the driver started calling the transmit API's not when the data actually starts being transmitted
    /// </summary>
    UINT64 SendStartQpcTime;

    /// <summary>
    /// Marks the time when the driver started transmission for this slice to the device
    /// NOTE : This marks the time the driver started calling the transmit API's not when the data actually starts being transmitted
    /// </summary>
    UINT64 SendStopQpcTime;

    /// <summary>
    /// Marks the time when the send was reported as complete by the OS
    /// This is a optional time stamp that can be used if the driver uses asynchronous transmit API and uses a completion routine
    /// in the event the driver does not have a asynchronous completion routine should set this value to zero
    /// </summary>
    UINT64 SendCompleteQpcTime;

    IDDCX_FRAME_STATISTICS_FLAGS Flags;

    /// <summary>
    /// The total number of pixels processed in this frame
    /// </summary>
    UINT ProcessedPixelCount;

    /// <summary>
    /// Total size of the data send to device for this frame, this includes all the slices
    /// </summary>
    UINT FrameSizeInBytes;
};

/// <summary>
/// Either IDDCX_SWAPCHAIN is a handle so we know when it is invalid or we have a driver callback
/// when the swapchain is destroyed so driver knows not to call this callback.
/// Need this resolve for the other swapchain callbacks as well
/// </summary>
struct IDARG_IN_REPORTFRAMESTATISTICS
{
    /// <summary>
    /// [in] Frame statics being reported
    /// </summary>
    IDDCX_FRAME_STATISTICS FrameStatistics;
};

struct IDARG_IN_I2C_TRANSMIT
{
    /// <summary>
    /// [in] The address of the I2C device from which data will be transmitted
    /// </summary>
    UINT SevenBitI2CAddress;

    /// <summary>
    /// [in] The size, in bytes, of the buffer pointed to by pData, this parameter must be between 1 and 64, inclusive
    /// </summary>
    UINT DataSizeInBytes;

    /// <summary>
    /// [in] A pointer to a buffer that holds the data to be transmitted
    /// </summary>
    _Field_size_full_(DataSizeInBytes) PVOID pData;
};

struct IDARG_IN_SET_GAMMARAMP
{
    /// <summary>
    /// [in] The type of gamma ramp being set
    /// </summary>
    IDDCX_GAMMARAMP_TYPE Type;

    /// <summary>
    /// [in] Size in bytes of the provided gamma ramp data.  Set to zero for IDDCX_GAMMARAMP_TYPE_DEFAULT
    /// </summary>
    UINT GammaRampSizeInBytes;

    /// <summary>
    /// [in] Pointer to gamma ramp data to set.  Set to NULL for IDDCX_GAMMARAMP_TYPE_DEFAULT
    /// </summary>
    _Field_size_bytes_opt_(GammaRampSizeInBytes) PVOID pGammaRampData;
};

struct IDARG_IN_I2C_RECEIVE
{
    /// <summary>
    /// [in] The address of the I2C device from which data will be received
    /// </summary>
    UINT SevenBitI2CAddress;

    /// <summary>
    /// [in] Flags for the receive operation
    /// </summary>
    UINT Flags;

    /// <summary>
    /// [in] The size, in bytes, of the buffer pointed to by pData
    /// </summary>
    UINT DataSizeInBytes;

    /// <summary>
    /// [out] A pointer to a buffer that receives the data.
    /// </summary>
    _Field_size_full_(DataSizeInBytes) PVOID pData;
};

struct IDARG_IN_OPM_GET_CERTIFICATE_SIZE
{
    /// <summary>
    /// [in] Type of certificate the size request is for
    /// </summary>
    OPM_VIDEO_OUTPUT_SEMANTICS CertificateType;
};

struct IDARG_OUT_OPM_GET_CERTIFICATE_SIZE
{
    /// <summary>
    /// [out] Size of certificate
    /// </summary>
    UINT CertificateSize;
};

struct IDARG_IN_OPM_GET_CERTIFICATE
{
    /// <summary>
    /// [in] Type of certificate the size request is for
    /// </summary>
    OPM_VIDEO_OUTPUT_SEMANTICS CertificateType;

    /// <summary>
    /// [in] Size of the buffer provided for the driver to copy the certificate to
    /// </summary>
    UINT CertificateBufferSizeInBytes;

    /// <summary>
    /// [out] A pointer to a buffer that the driver copies the certificate to.
    /// </summary>
    _Field_size_full_(CertificateBufferSizeInBytes) PVOID pCertificate;
};

struct IDARG_IN_OPM_CREATE_PROTECTED_OUTPUT
{
    /// <summary>
    /// [in] Type of semantics for this context
    /// </summary>
    OPM_VIDEO_OUTPUT_SEMANTICS VideoOutputSemantics;
};

struct IDDCX_OPM_GET_RANDOM_NUMBER
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The random number the driver generated
    /// </summary>
    OPM_RANDOM_NUMBER RandomNumber;
};

struct IDARG_OUT_OPM_GET_RANDOM_NUMBER
{
    /// <summary>
    /// [out] The random number the driver generated
    /// </summary>
    IDDCX_OPM_GET_RANDOM_NUMBER RandomNumber;
};

struct IDDCX_OPM_ENCRYPTED_INITIALIZATION_PARAMETERS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Initialization parameters
    /// </summary>
    OPM_ENCRYPTED_INITIALIZATION_PARAMETERS EncryptedParameters;
};

struct IDARG_IN_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS
{
    /// <summary>
    /// [in] Initialization parameters
    /// </summary>
    IDDCX_OPM_ENCRYPTED_INITIALIZATION_PARAMETERS EncryptedParameters;
};

struct IDDCX_OPM_GET_INFO_PARAMETERS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Parameters for the get information request
    /// </summary>
    OPM_GET_INFO_PARAMETERS GetInfoParameters;
};

struct IDARG_IN_OPM_GET_INFOMATION
{
    /// <summary>
    /// [in] Parameters for the get information request
    /// </summary>
    IDDCX_OPM_GET_INFO_PARAMETERS GetInfoParameters;
};

struct IDDCX_OPM_REQUESTED_INFORMATION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The information that was requested
    /// </summary>
    OPM_REQUESTED_INFORMATION RequestedInformation;
};

struct IDARG_OUT_OPM_GET_INFOMATION
{
    /// <summary>
    /// [out] The information that was requested
    /// </summary>
    IDDCX_OPM_REQUESTED_INFORMATION RequestedInformation;
};

struct IDDCX_OPM_CONFIGURE_PARAMETERS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Configuration parameters
    /// </summary>
    OPM_CONFIGURE_PARAMETERS ConfigParameters;
};

struct IDARG_IN_OPM_CONFIGURE_PROTECTED_OUTPUT
{
    /// <summary>
    /// [in] Configuration parameters
    /// </summary>
    IDDCX_OPM_CONFIGURE_PARAMETERS ConfigParameters;

    /// <summary>
    /// [in] Size of additional parameter buffer
    /// </summary>
    UINT AdditionalParametersSizeInBytes;

    /// <summary>
    /// [in] A pointer to a buffer that the driver copies the certificate to.
    /// </summary>
    _Field_size_full_(AdditionalParametersSizeInBytes) PVOID pAdditionalParameters;
};

struct IDARG_OUT_GETVERSION
{
    /// <summary>
    /// [out] Configuration parameters
    /// </summary>
    ULONG IddCxVersion;
};

struct IDARG_IN_REPORTCRITICALERROR
{
    /// <summary>
    /// [In] The major error code for this critical error.  Valid range 0-0xff inclusive.
    /// IddCx will add 0x100 to this value before passing to Windows Error Reporting when creating memory dump
    /// </summary>
    ULONG MajorErrorCode;

    /// <summary>
    /// [In] The minor error code for this critical error.  Valid range 0-0xff inclusive
    /// </summary>
    ULONG MinorErrorCode;
};

struct IDARG_IN_SETSRMLIST
{
    /// <summary>
    /// [in] The size, in bytes, of the buffer pointed to by pSrmList
    /// </summary>
    UINT SrmListSizeInBytes;

    /// <summary>
    /// [in] A pointer to a buffer that holds the SRM list to pass to the appropriate
    /// Wddm driver. This buffer should contain the SRM in the format required by
    /// Digital Content Protection LLC for HDCP
    /// </summary>
    _Field_size_full_(SrmListSizeInBytes) PVOID pSrmList;
};

struct IDARG_IN_GETSRMLISTVERSION
{
    /// <summary>
    /// [in] The size in bytes of the pSrmListVerion being passed by driver to the OS
    /// A value of zero indicates that the driver is just querying the size of
    /// the SRM list version buffer that should be provided by the driver, in
    /// this case the OS will set buffer size in the output structure.
    /// Either SrmListVersionBufferInputCount needs to be zero and pSrmListVerion
    /// set to null or SrmListVersionBufferInputCount needs to be non-zero and
    /// pSrmListVerion needs to be non-null
    /// </summary>
    UINT SrmListVersionBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer that OS should copy the SRM list version to if
    /// the value is non-NULL.  In this case the format of the version is defined by
    /// the PlayReady Porting Kit 4.0.
    /// If value is NULL then OS will not copy any data and OS will set the value
    /// IDARG_OUT_GETSRMLISTVERSION.SrmListVersionBufferOutputCount to indicate
    /// the size of buffer required to store the SRM list version
    /// </summary>
    _Field_size_opt_(SrmListVersionBufferInputCount) PVOID pSrmListVerion;
};

struct IDARG_OUT_GETSRMLISTVERSION
{
    /// <summary>
    /// [out] If IDARG_IN_GETSRMLISTVERSION.pSrmListVerion was NULL then OS will
    /// set this to the size of the buffer necessary to read the SRM list version
    /// description.
    /// If IDARG_IN_GETSRMLISTVERSION.pSrmListVerion was non-NULL then this
    /// is the number of bytes returned in
    /// IDARG_IN_GETSRMLISTVERSION.pSrmListVerion buffer
    /// If there was no SRM list set then SrmListVersionBufferOutputCount will be
    /// set to zero.
    /// </summary>
    UINT SrmListVersionBufferOutputCount;
};

struct IDARG_IN_ADAPTERSETRENDERADAPTER
{
    /// <summary>
    /// The LUID of the render adapter that the driver would like to be used 
    /// to rendered the desktop image for the swapchains on this adapter.  
    /// Setting a value of {0, 0} indicates that the driver has no preference for 
    /// the render adapter used.
    /// This is a preference and the OS may decide to use a different render adapter
    /// for example if the specified adapter has been PnpStopped then the OS will 
    /// pick an alternative
    /// </summary>
    LUID PreferredRenderAdapter;
};

struct IDDCX_DISPLAYCONFIGPATH
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;
 
    /// <summary>
    /// The handle the driver provides to identify the monitor this 
    /// path is targeted at
    /// </summary>
    IDDCX_MONITOR MonitorObject;
 
    /// <summary>
    /// Requested desktop position for this path.
    /// </summary>        
    POINT Position;
 
    /// <summary>
    /// Desktop resolution for this path.
    /// Must match a resolution supported by the driver
    /// </summary>
    DISPLAYCONFIG_2DREGION Resolution;
      
    /// <summary>
    /// Requested orientation for this path
    /// </summary>        
    DISPLAYCONFIG_ROTATION Rotation;
 
    /// <summary>
    /// Requested refresh rate for this path
    /// Must match a refresh rate supported by the driver for this resolution
    /// NOTE: This refresh rate is defined as progressive as remote drivers can
    /// only support progressive target modes
    /// </summary>        
    DISPLAYCONFIG_RATIONAL RefreshRate;

    /// <summary>
    /// The V Sync divider value for the specified RefreshRate
    /// </summary>        
    UINT VSyncFreqDivider;
 
    /// <summary>
    /// Requested monitor DPI for this path, note this value is just a hint 
    /// and OS may override the value to ensure the DPI configuration of 
    /// the session is valid
    /// Valid values are 100 to 500 inclusive
    /// </summary>        
    UINT MonitorScaleFactor;

    /// <summary>
    /// Physical width override for the specified monitor in millimeters, zero means no override
    /// </summary>
    UINT PhysicalWidthOverride;
 
    /// <summary>
    /// Physical height override for the specified monitor in millimeters, zero means no override
    /// </summary>
    UINT PhysicalHeightOverride;
};

struct IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE
{
    /// <summary>   
    /// [in] The number of paths in the pPaths array, this cannot be zero
    /// </summary>
    UINT PathCount;
 
    /// <summary>
    /// [in] Pointer to array of path display configuration
    /// </summary>
    _Field_size_(PathCount) IDDCX_DISPLAYCONFIGPATH* pPaths;
};

struct IDARG_OUT_MONITORGETPHYSICALSIZE
{
    /// <summary>
    /// Physical width of the specified monitor in millimeters, value cannot be zero
    /// </summary>
    UINT PhysicalWidth;
 
    /// <summary>
    /// Physical height of the specified monitor in millimeters, value cannot be zero
    /// </summary>
    UINT PhysicalHeight;
};

struct IDDCX_SYSTEM_BUFFER_INFO
{
    /// <summary>
    /// Total size of the structure in number of bytes
    /// </summary>
    UINT Size;

    /// <summary>
    /// Pitch/Stride of the surface in number of bytes
    /// </summary>
    UINT Pitch;

    /// <summary>
    /// Height of the surface in number of pixels
    /// </summary>
    UINT Height;

    /// <summary>
    /// Width of the surface in number of pixels
    /// </summary>
    UINT Width;

    /// <summary>
    /// Format of the surface pixel
    /// </summary>
    DXGI_FORMAT Format;

    /// <summary>
    /// A pointer (at-least 16 byte aligned) in system memory to the surface buffer
    /// </summary>
    VOID *pBuffer;
};

struct IDARG_OUT_RELEASEANDACQUIRESYSTEMBUFFER
{
    /// <summary>
    /// [out] Pointer to the struct containing per-frame metadata and frame information
    /// </summary>
    IDDCX_METADATA *pMetaData;

    /// <summary>
    /// [out] Pointer to the struct containing buffer's surface information
    /// </summary>
    IDDCX_SYSTEM_BUFFER_INFO *pBufferInfo;
};

struct IDARG_IN_SETREALTIMEGPUPRIORITY
{
    /// <summary>
    /// The DXGI device that the caller is requesting realtime GPU priority for
    /// </summary>
    IDXGIDevice* pDevice;
};

struct IDDCX_WIRE_BITS_PER_COMPONENT
{
    /// <summary>
    /// Describes supported/requested pixel encoding using RGB sample format.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT Rgb;

    /// <summary>
    /// Describes supported/requested pixel encoding using YCbCr 4:4:4 sample format.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT YCbCr444;

    /// <summary>
    /// Describes supported/requested pixel encoding using YCbCr 4:2:2 sample format.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT YCbCr422;

    /// <summary>
    /// Describes supported/requested pixel encoding using YCbCr 4:2:0 sample format.
    /// </summary>
    IDDCX_BITS_PER_COMPONENT YCbCr420;
};

struct IDARG_IN_QUERYTARGET_INFO
{
    /// <summary>
    /// Indicates which target is being referred to. Must match IDDCX_MONITOR_INFO::ConnectorIndex passed to IddCxMonitorCreate
    /// </summary>
    UINT ConnectorIndex;
};

struct IDARG_OUT_QUERYTARGET_INFO
{
    /// <summary>
    /// Capabilities of the target
    /// </summary>
    IDDCX_TARGET_CAPS TargetCaps;

    /// <summary>
    /// The driver should set the wire-format bit for each format where the driver and hardware supports dithering beneficial to image quality when
    /// the source pixel format is higher precision that than the wire-format.
    /// </summary>
    IDDCX_WIRE_BITS_PER_COMPONENT DitheringSupport;
};

struct IDDCX_HDR10_METADATA
{
    /// <summary>
    /// The chromaticity coordinates of the red value in the CIE1931 color space. Index 0 contains the X coordinate and index 1 contains the Y coordinate.
    /// The values normalized to 50,000, i.e. 1 == 0.00002.
    /// </summary>
    USHORT RedPrimary[2];

    /// <summary>
    /// The chromaticity coordinates of the green value in the CIE1931 color space. Index 0 contains the X coordinate and index 1 contains the Y coordinate.
    /// The values normalized to 50,000, i.e. 1 == 0.00002.
    /// </summary>
    USHORT GreenPrimary[2];

    /// <summary>
    /// The chromaticity coordinates of the blue value in the CIE1931 color space. Index 0 contains the X coordinate and index 1 contains the Y coordinate.
    /// The values normalized to 50,000, i.e. 1 == 0.00002.
    /// </summary>
    USHORT BluePrimary[2];

    /// <summary>
    /// The chromaticity coordinates of the white point in the CIE1931 color space. Index 0 contains the X coordinate and index 1 contains the Y coordinate.
    /// The values normalized to 50,000, i.e. 1 == 0.00002.
    /// </summary>
    USHORT WhitePoint[2];

    /// <summary>
    /// The maximum number of nits of the display used to master the content.
    /// Values are in whole nits.
    /// </summary>
    USHORT MaxMasteringLuminance;

    /// <summary>
    /// The minimum number of nits of the display used to master the content.
    /// The values normalized to 10,000, i.e. 1 == 0.0001.
    /// </summary>
    USHORT MinMasteringLuminance;

    /// <summary>
    /// The maximum content light level (MaxCLL). This is the nit value corresponding to the brightest pixel used anywhere in the content.
    /// Values are in whole nits.
    /// </summary>
    USHORT MaxContentLightLevel;

    /// <summary>
    /// The maximum frame average light level (MaxFALL). This is the nit value corresponding to the average luminance of the frame which
    /// has the brightest average luminance anywhere in the content.
    /// Values are in whole nits.
    /// </summary>
    USHORT MaxFrameAverageLightLevel;
};

struct IDARG_IN_MONITOR_SET_DEFAULT_HDR_METADATA
{
    /// <summary>
    /// The type of the meta data pointed to by IDARG_IN_MONITOR_SET_DEFAULT_HDR_METADATA::Data
    /// </summary>
    IDDCX_DEFAULT_HDR_METADATA_TYPE Type;

    /// <summary>
    /// The size of the buffer pointed to by IDARG_IN_MONITOR_SET_DEFAULT_HDR_METADATA::Data in bytes
    /// </summary>
    UINT Size;

    union
    {
        /// <summary>
        /// A pointer to an IDDCX_HDR10_METADATA structure containing meta data a driver is to save and use if requested later.
        /// </summary>
        IDDCX_HDR10_METADATA* pHdr10;
    } Data;
};

struct IDDCX_MONITOR_MODE2
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Where the driver derived this mode from
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN Origin;

    /// <summary>
    /// This is the details of the Monitor mode. Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// </summary>
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO MonitorVideoSignalInfo;

    /// <summary>
    /// How many bits per component can be used to send pixels of each format to a monitor
    /// </summary>
    IDDCX_WIRE_BITS_PER_COMPONENT BitsPerComponent;
};

struct IDARG_IN_PARSEMONITORDESCRIPTION2
{
    /// <summary>
    /// Monitor description the driver should decode.
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// The number of monitor modes the pMonitorModes buffer being passed into the driver can hold. A value of zero indicates that the driver should
    /// not copy the monitor mode list into the provided buffer, but should set the IDARG_OUT_PARSEMONITORDESCRIPTION value MonitorModeBufferOutputCount
    /// to indicate the size of buffer required to store the modes.
    /// </summary>
    UINT MonitorModeBufferInputCount;

    /// <summary>
    /// Pointer to buffer that the driver should copy the monitor modes to if the value is non-NULL. If value is NULL, then driver should not copy any
    /// data and should just set the IDARG_OUT_PARSEMONITORDESCRIPTION value MonitorModeBufferOutputCount to indicate the size of buffer required to store the modes.
    /// </summary>
    _Field_size_opt_(MonitorModeBufferInputCount) IDDCX_MONITOR_MODE2 *pMonitorModes;
};

struct IDDCX_TARGET_MODE2
{
    /// <summary>
    /// Size of the structure, in bytes.
    /// </summary>
    UINT Size;

    /// <summary>
    /// A DISPLAYCONFIG_TARGET_MODE structure that describes the display path target mode, including information about the video signal for the display.
    /// </summary>
    DISPLAYCONFIG_TARGET_MODE TargetVideoSignalInfo;

    /// <summary>
    /// The display pipeline bandwidth required for this mode. The driver reports pipeline bandwidth in IDDCX_ADAPTER_CAPS.MaxDisplayPipelineRate.
    /// The OS will never pick a combination of modes across all targets that exceeds this value.
    /// </summary>
    UINT64 RequiredBandwidth;

    /// <summary>
    /// How many bits per component can be used to send pixels of each format to a monitor
    /// </summary>
    IDDCX_WIRE_BITS_PER_COMPONENT BitsPerComponent;
};

struct IDARG_IN_QUERYTARGETMODES2
{
    /// <summary>
    /// The monitor description.
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// The number of target modes the pTargetModes buffer passed to the driver can hold. If the value is zero, then the driver should not copy
    /// the target mode list to pTargetModes, but should set the IDARG_OUT_QUERYTARGETMODES value TargetModeBufferOutputCount to indicate the
    /// size of buffer required to store the modes.
    /// </summary>
    UINT TargetModeBufferInputCount;

    /// <summary>
    /// Pointer to buffer that the driver should copy the target modes to if the value is non-NULL. If value is NULL, then driver should not
    /// copy any data and should just set the IDARG_OUT_QUERYTARGETMODES value TargetModeBufferOutputCount to indicate the size of buffer
    /// required to store the modes.
    /// </summary>
    _Field_size_(TargetModeBufferInputCount) IDDCX_TARGET_MODE2 *pTargetModes;
};

struct IDDCX_WIRE_FORMAT_INFO
{
    /// <summary>
    /// The color space to be used on the monitor
    /// </summary>
    IDDCX_COLOR_SPACE ColorSpace;

    /// <summary>
    /// How many bits per component and which pixel encoding to be used
    /// </summary>
    IDDCX_WIRE_BITS_PER_COMPONENT BitsPerComponent;
};

struct IDDCX_PATH2
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The handle the driver provides to identify the monitor this path is targeted at
    /// </summary>
    IDDCX_MONITOR MonitorObject;

    /// <summary>
    /// Contains flags for this path, like the path's active state and whether it changed.
    /// </summary>
    IDDCX_PATH_FLAGS Flags;

    /// <summary>
    /// This is the details of the target mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// NOTE : DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq is the Vsync rate between the Indirect Display device and the
    /// connected monitor.  DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider is used to
    /// calculate the rate at which the OS will update the desktop image.
    /// The desktop update rate will calculate be :
    ///    DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq / DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider
    /// DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider cannot be zero
    /// </summary>
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO TargetVideoSignalInfo;

    /// <summary>
    /// Details of the signal that should be sent to the monitor
    /// </summary>
    IDDCX_WIRE_FORMAT_INFO WireFormatInfo;
};

struct IDARG_IN_COMMITMODES2
{
    /// <summary>
    /// The number of paths in the pPaths array
    /// </summary>
    UINT PathCount;

    /// <summary>
    /// A pointer to the array of paths that need to be committed.
    /// </summary>
    _Field_size_(PathCount) IDDCX_PATH2 *pPaths;
};

struct IDDCX_GAMMARAMP_RGB256x3x16
{
    /// <summary>
    /// An array of 16-bit values that holds the gamma function for the red color channel.
    /// </summary>
    USHORT Red[256];

    /// <summary>
    /// An array of 16-bit values that holds the gamma function for the green color channel.
    /// </summary>
    USHORT Green[256];

    /// <summary>
    /// An array of 16-bit values that holds the gamma function for the blue color channel.
    /// </summary>
    USHORT Blue[256];
};

struct IDDCX_RGB
{
    /// <summary>
    /// A floating point value that is used to describe the gamma function for the red color channel.
    /// </summary>
    float Red;

    /// <summary>
    /// A floating point value that is used to describe the gamma function for the green color channel.
    /// </summary>
    float Green;

    /// <summary>
    /// A floating point value that is used to describe the gamma function for the blue color channel.
    /// </summary>
    float Blue;
};

struct IDDCX_GAMMARAMP_3X4_COLORSPACE_TRANSFORM
{
    /// <summary>
    /// If true, ColorMatrix3x4 contains a valid matrix and ScalarMultiplier contains a valid value, both of which should be applied.
    /// </summary>
    BOOL MatrixEnabled;

    /// <summary>
    /// A 3x3 matrix and 3x1 addition to be applied to each pixel, stored in row-major order. Transforms colors within CIEXYZ.
    /// </summary>
    float ColorMatrix3x4[3][4];

    /// <summary>
    /// A scalar to be multiplied into each element of ColorMatrix3x4.
    /// </summary>
    float ScalarMultiplier;

    /// <summary>
    /// If true, LookupTable1D contains a valid table which should be applied.
    /// </summary>
    BOOL LutEnabled;

    /// <summary>
    /// 1D look-up table. Transforms colors within the color space specified by IDDCX_PATH2::WireFormatInfo.ColorSpace.
    /// </summary>
    IDDCX_RGB LookupTable1D[4096];
};

struct IDARG_IN_RELEASEANDACQUIREBUFFER2
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// A driver can set this to TRUE in order for the OS to fill out an IDDCX_SYSTEM_BUFFER_INFO structure in IDDCX_METADATA2. This is equivalent
    /// to an older driver calling IddCxSwapChainReleaseAndAcquireSystemBuffer instead of IddCxSwapChainReleaseAndAcquireBuffer.
    /// </summary>
    BOOL AcquireSystemMemoryBuffer;
};

struct IDDCX_HDR10_FRAME_METADATA
{
    /// <summary>
    /// Tells the driver what type of meta data to use with this frame
    /// </summary>
    IDDCX_HDR10_FRAME_METADATA_TYPE Type;

    /// <summary>
    /// If Type is IDDCX_HDR10_FRAME_METADATA_TYPE_NEW this is the new meta data block
    /// </summary>
    IDDCX_HDR10_METADATA NewMetaData;
};

struct IDDCX_METADATA2
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT                        Size;

    /// <summary>
    /// Indicate which sections of this IDDCX_METADATA2 structure have valid contents
    /// </summary>
    IDDCX_METADATA2_VALID_FLAGS ValidFlags;

    /// <summary>
    /// Presentation frame number of this surface.
    /// </summary>
    UINT                        PresentationFrameNumber;

    /// <summary>
    /// Number of dirty rects for this frame. Call IddCxSwapChainGetDirtyRects to get the dirty rects.
    /// A DirtyRectCount of 1, where the single dirty rect has all values set to zero, indicates that there has not been any image updates from the
    /// previous frame. This is an opportunity for the driver to re-encode the desktop image again to increase the visual quality. Once there are no
    /// more updates, the OS presents the same frame as many times as indicated by the IDDCX_ADAPTER_CAPS value StaticDesktopReencodeFrameCount, then
    /// stops presenting until the next update.
    /// </summary>
    UINT                        DirtyRectCount;

    /// <summary>
    /// Indicates whether the provided surface is hardware protected.
    /// </summary>
    BOOL                        HwProtectedSurface;

    /// <summary>
    /// System QPC time of when this surface should be displayed on the indirect display monitor.
    /// </summary>
    UINT64                      PresentDisplayQPCTime;

    /// <summary>
    /// DX surface that contains the image to encode and transmit. The driver can use this DX surface anytime until IddCxSwapChainReleaseAndAcquire is called again.
    /// </summary>
    IDXGIResource*              pSurface;

    /// <summary>
    /// The color space of the supplied surface which typically matches that specified in the committed path
    /// </summary>
    DXGI_COLOR_SPACE_TYPE       SurfaceColorSpace;

    /// <summary>
    /// The white level in nits for any SDR content, for example the mouse cursor. This will default to 80 nits for non HDR modes.
    /// </summary>
    UINT                        SdrWhiteLevel;

    /// <summary>
    /// An IDARG_OUT_RELEASEANDACQUIRESYSTEMBUFFER structure in which the resulting information from the release and acquire operation is returned.
    /// </summary>
    IDDCX_SYSTEM_BUFFER_INFO    SystemBufferInfo;

    /// <summary>
    /// Details of the HDR meta data to be used with this frame
    /// </summary>
    IDDCX_HDR10_FRAME_METADATA  Hdr10FrameMetaData;
};

struct IDARG_OUT_RELEASEANDACQUIREBUFFER2
{
    /// <summary>
    /// The meta data that accompanies the new buffer
    /// </summary>
    IDDCX_METADATA2 MetaData;
};

struct IDARG_OUT_QUERY_HWCURSOR3
{
    /// <summary>
    /// [out] Indicates if the cursor is visible or not.
    /// </summary>
    BOOL IsCursorVisible;

    /// <summary>
    /// [out] If the cursor is visible then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// Only valid if PositionValid is TRUE
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT X;

    /// <summary>
    /// [out] If the cursor is visible then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// Only valid if PositionValid is TRUE
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT Y;

    /// <summary>
    /// [out] Indicates if the cursor shape has been updated since the last time the driver called, if it has been updated
    /// then the OS updated the CursorShapeInfo structure and also copied the new cursor image data into the
    /// IDARG_IN_QUERY_HWCURSOR.pShapeBuffer buffer
    /// </summary>
    BOOL IsCursorShapeUpdated;

    /// <summary>
    /// [out] If cursor visible then OS will copy the current cursor info into this buffer, if cursor is not visible then
    /// OS will zero this structure
    /// </summary>
    IDDCX_CURSOR_SHAPE_INFO CursorShapeInfo;

    /// <summary>
    /// [out] Indicates if the X, Y and PositionId fields in this structure are valid or not
    /// </summary>
    BOOL PositionValid;

    /// <summary>
    /// [out] The position id of the last cursor position that the OS received for this monitor, the driver can
    /// compare this to the last cursor position that it processed to know it should process a new position update.
    /// Note that there are cases where the position values may not changed but position id value has changed, in this
    /// case the driver should process the position as if it was a new move.
    /// PositionId is not updated if IsCursorVisible changes
    /// Only valid if PositionValid is TRUE
    /// </summary>
    UINT PositionId;

    /// <summary>
    /// The white level in nits for the cursor, to be used when compositing with HDR content.
    /// </summary>
    UINT SdrWhiteLevel;
};

struct IDDCX_DISPLAYCONFIG_MODE
{
    /// <summary>
    /// A POINT structure containing the requested desktop position for this path.
    /// </summary>
    POINT                  Position;

    /// <summary>
    /// A DISPLAYCONFIG_2DREGION structure containing the resolution for this path. Resolution must match a resolution supported by the driver.
    /// </summary>
    DISPLAYCONFIG_2DREGION Resolution;

    /// <summary>
    /// A DISPLAYCONFIG_ROTATION value specifying the requested screen orientation for this path.
    /// </summary>
    DISPLAYCONFIG_ROTATION Rotation;

    /// <summary>
    /// A DISPLAYCONFIG_RATIONAL structure containing the requested refresh rate for this path. RefreshRate must match a refresh rate supported by the
    /// driver for the specified resolution. Note: This refresh rate is defined as progressive as remote drivers can only support progressive target modes.
    /// </summary>
    DISPLAYCONFIG_RATIONAL RefreshRate;

    /// <summary>
    /// The V Sync divider value for the specified RefreshRate.
    /// </summary>
    UINT                   VSyncFreqDivider;

    /// <summary>
    /// The color mode to be set on this monitor
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORMODE   MonitorColorMode;
};

struct IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY
{
    /// <summary>
    /// Override for display red point. Note, each dimension is a 10-bit value stored in the least significant bits. Zero indicates no override.
    /// </summary>
    DISPLAYCONFIG_2DREGION             RedPoint;

    /// <summary>
    /// Override for display green point. Note, each dimension is a 10-bit value stored in the least significant bits.
    /// </summary>
    DISPLAYCONFIG_2DREGION             GreenPoint;

    /// <summary>
    /// Override for display blue point. Note, each dimension is a 10-bit value stored in the least significant bits.
    /// </summary>
    DISPLAYCONFIG_2DREGION             BluePoint;

    /// <summary>
    /// Override for display white point. Note, each dimension is a 10-bit value stored in the least significant bits.
    /// </summary>
    DISPLAYCONFIG_2DREGION             WhitePoint;

    /// <summary>
    /// Override for the minimum luminance value supported by the display measured in one ten thousandth of a nit. Only valid if MaxLuminance is non-zero.
    /// Zero is a valid value.
    /// </summary>
    ULONG                              MinLuminance;

    /// <summary>
    /// Override for the maximum luminance value supported by the display measured in one ten thousandth of a nit. This luminance level is expected to be
    /// supported for only a relatively small area in any given frame. Zero indicates no override of MaxLuminance, MaxFullFrameLuminance or MinLuminance.
    /// </summary>
    ULONG                              MaxLuminance;

    /// <summary>
    /// Override for the max full frame luminance value supported by the display measured in one ten thousandth of a nit. This luminance level must be
    /// supported across every pixel in the frame simultaneously in order to provide an estimate of the average luminance value which can be supported
    /// by the display across a frame. Only valid if MaxLuminance is non-zero. Zero is not a valid override.
    /// </summary>
    ULONG                              MaxFullFrameLuminance;

    /// <summary>
    /// Overrides the supported bits per color component in each of the color encodings specified. At least one bit must be set one of the color encodings.
    /// </summary>
    IDDCX_WIRE_BITS_PER_COMPONENT      BitsPerComponent;

    /// <summary>
    /// Indicates support for specific colorimetry and EOTF capabilities.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY_FLAGS    Flags;
};

struct IDDCX_DISPLAYCONFIGPATH2
{
    /// <summary>
    /// Size, in bytes, of this structure.
    /// </summary>
    UINT Size;

    /// <summary>
    /// The flags for this path including which fields contain valid data
    /// </summary>
    IDDCX_DISPLAYCONFIGPATH2_FLAGS Flags;

    /// <summary>
    /// Monitor object handle that the driver provides to identify the monitor this path is targeted at.
    /// </summary>
    IDDCX_MONITOR                   MonitorObject;

    /// <summary>
    /// If valid, details of the mode to be set for the monitor in this path.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MODE        Mode;

    /// <summary>
    /// If valid, The requested monitor DPI for this path. Note that this value is just a hint and OS may override the value to ensure the DPI
    /// configuration of the session is valid. Valid values are 100 to 500 inclusive.
    /// </summary>
    UINT                            MonitorScaleFactor;

    /// <summary>
    /// If valid, physical width and height override for the specified monitor, in millimeters. A value of zero means no override.
    /// </summary>
    DISPLAYCONFIG_2DREGION          MonitorPhysicalSize;

    /// <summary>
    /// If valid, colorimetry details for the specified monitor.
    /// </summary>
    IDDCX_DISPLAYCONFIG_MONITOR_COLORIMETRY MonitorColorimetry;

    /// <summary>
    /// If valid, the new white level, in nits, to be used for SDR content on this monitor when in an HDR mode.
    /// Valid values are 80 to 480 inclusive.
    /// </summary>
    UINT                            MonitorSdrWhiteLevel;
};

struct IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE2
{
    /// <summary>   
    /// [in] The number of paths in the pPaths array, this cannot be zero
    /// </summary>
    _In_ UINT PathCount;

    /// <summary>
    /// [in] Pointer to array of IDDCX_DISPLAYCONFIGPATH2 structures
    /// </summary>
    _Field_size_(PathCount) _In_ IDDCX_DISPLAYCONFIGPATH2 *pPaths;
};

struct IDARG_IN_UPDATEMODES2
{
    /// <summary>
    /// Indicates the reason why the driver is updating the modes
    /// </summary>
    IDDCX_UPDATE_REASON Reason;

    /// <summary>
    /// [in] Number of target modes in the pTargetModes buffer.  This cannot be zero
    /// </summary>
    UINT TargetModeCount;

    /// <summary>
    /// [in] Pointer to buffer driver should copy the target modes it supports for this monitor
    /// </summary>
    _Field_size_(TargetModeCount) IDDCX_TARGET_MODE2* pTargetModes;
};

#pragma endregion

#pragma region Structure Initialization

VOID
FORCEINLINE
IDD_CX_CLIENT_CONFIG_INIT(
    _Out_ IDD_CX_CLIENT_CONFIG* Config
    )
{
    RtlZeroMemory(Config, sizeof(IDD_CX_CLIENT_CONFIG));
    Config->Size = IDD_STRUCTURE_SIZE(IDD_CX_CLIENT_CONFIG);
}

#pragma endregion

#pragma region Indirect Display APIs

//
// IDD Function: IddCxDeviceInitConfig
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXDEVICEINITCONFIG)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PWDFDEVICE_INIT DeviceInit,
    _In_
    CONST IDD_CX_CLIENT_CONFIG* Config
    );

/// <summary>
/// Inits a WDFDEVICE initialization structure to allow indirect displays to be used.
/// </summary>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxDeviceInitConfig(
    _Inout_
    PWDFDEVICE_INIT DeviceInit,
    _In_
    CONST IDD_CX_CLIENT_CONFIG* Config
    )
{
    return ((PFN_IDDCXDEVICEINITCONFIG) IddFunctions[IddCxDeviceInitConfigTableIndex])(IddDriverGlobals, DeviceInit, Config);
}

//
// IDD Function: IddCxDeviceInitialize
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXDEVICEINITIALIZE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    WDFDEVICE Device
    );

/// <summary>
/// Initializes a WDF device
/// </summary>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxDeviceInitialize(
    _In_
    WDFDEVICE Device
    )
{
    return ((PFN_IDDCXDEVICEINITIALIZE) IddFunctions[IddCxDeviceInitializeTableIndex])(IddDriverGlobals, Device);
}

//
// IDD Function: IddCxAdapterInitAsync
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXADAPTERINITASYNC)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    CONST IDARG_IN_ADAPTER_INIT* pInArgs,
    _Out_
    IDARG_OUT_ADAPTER_INIT* pOutArgs
    );

/// <summary>
/// This will be called by driver to create a WDDM graphics adapter
/// </summary>
/// <param name="hDriverAdapterContext">The handle the driver provides so the OS can reference this adapter when calling the driver</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxAdapterInitAsync(
    _In_
    CONST IDARG_IN_ADAPTER_INIT* pInArgs,
    _Out_
    IDARG_OUT_ADAPTER_INIT* pOutArgs
    )
{
    return ((PFN_IDDCXADAPTERINITASYNC) IddFunctions[IddCxAdapterInitAsyncTableIndex])(IddDriverGlobals, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxMonitorCreate
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORCREATE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_MONITORCREATE* pInArgs,
    _Out_
    IDARG_OUT_MONITORCREATE* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls to create a monitor object that can later be used for arrival.
/// </summary>
/// <param name="AdapterObject">The adapter object that is hosting the newly arrived monitor</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise it returns one the follwing error codes:
/// STATUS_MONITOR_NO_DESCRIPTOR - Only DisplayID is present, but no EDID
/// STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM - DisplayID checksum is incorrect
/// STATUS_NOT_SUPPORTED - Too many target modes
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorCreate(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_MONITORCREATE* pInArgs,
    _Out_
    IDARG_OUT_MONITORCREATE* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORCREATE) IddFunctions[IddCxMonitorCreateTableIndex])(IddDriverGlobals, AdapterObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxMonitorArrival
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORARRIVAL)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _Out_
    IDARG_OUT_MONITORARRIVAL* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls report a monitor arrival on the WDDM graphics adapter
/// </summary>
/// <param name="MonitorObject">The monitor object that is hosting the newly arrived monitor</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorArrival(
    _In_
    IDDCX_MONITOR MonitorObject,
    _Out_
    IDARG_OUT_MONITORARRIVAL* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORARRIVAL) IddFunctions[IddCxMonitorArrivalTableIndex])(IddDriverGlobals, MonitorObject, pOutArgs);
}

//
// IDD Function: IddCxMonitorDeparture
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORDEPARTURE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject
    );

/// <summary>
/// An OS callback function the driver calls report a monitor departure from the WDDM graphics adapter
/// </summary>
/// <param name="MonitorObject">The monitor object that is departing</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorDeparture(
    _In_
    IDDCX_MONITOR MonitorObject
    )
{
    return ((PFN_IDDCXMONITORDEPARTURE) IddFunctions[IddCxMonitorDepartureTableIndex])(IddDriverGlobals, MonitorObject);
}

//
// IDD Function: IddCxMonitorUpdateModes
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORUPDATEMODES)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_UPDATEMODES* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls to update the mode list
/// </summary>
/// <param name="MonitorObject">The monitor object being updated</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorUpdateModes(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_UPDATEMODES* pInArgs
    )
{
    return ((PFN_IDDCXMONITORUPDATEMODES) IddFunctions[IddCxMonitorUpdateModesTableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
}

//
// IDD Function: IddCxAdapterUpdateMaxDisplayPipelineRate
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXADAPTERUPDATEMAXDISPLAYPIPELINERATE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER hOsAdapterContext,
    _In_
    CONST IDARG_IN_MAXDISPLAYPIPELINERATE* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls report that the max display pipeline rate has changed
/// </summary>
/// <param name="hOsAdapterContext">This is the OS context handle for this adapter returned by the IddCxSTart call</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxAdapterUpdateMaxDisplayPipelineRate(
    _In_
    IDDCX_ADAPTER hOsAdapterContext,
    _In_
    CONST IDARG_IN_MAXDISPLAYPIPELINERATE* pInArgs
    )
{
    return ((PFN_IDDCXADAPTERUPDATEMAXDISPLAYPIPELINERATE) IddFunctions[IddCxAdapterUpdateMaxDisplayPipelineRateTableIndex])(IddDriverGlobals, hOsAdapterContext, pInArgs);
}

//
// IDD Function: IddCxMonitorSetupHardwareCursor
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORSETUPHARDWARECURSOR)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_SETUP_HWCURSOR* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to setup hardware cursor support for the path.  By default when a
/// mode is committed on a path software cursor is enabled, if the driver want to accelerate the cursor on that path it uses
/// this callback to enable hardware cursor support
/// </summary>
/// <param name="MonitorObject">The handle the OS provided to identify the monitor</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorSetupHardwareCursor(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_SETUP_HWCURSOR* pInArgs
    )
{
    return ((PFN_IDDCXMONITORSETUPHARDWARECURSOR) IddFunctions[IddCxMonitorSetupHardwareCursorTableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
}

//
// IDD Function: IddCxMonitorQueryHardwareCursor
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORQUERYHARDWARECURSOR)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants obtain the updated cursor information, driver normally only calls
/// this when the event that signals cursor update has triggered
/// </summary>
/// <param name="MonitorObject">This is the OS context handle for this monitor returned by the IddCxMonitorArrival call</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorQueryHardwareCursor(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORQUERYHARDWARECURSOR) IddFunctions[IddCxMonitorQueryHardwareCursorTableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxSwapChainSetDevice
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINSETDEVICE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_SWAPCHAINSETDEVICE* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls within its SetSwapChain routine to setup the swap-chain with a particular DXGI device.
/// </summary>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainSetDevice(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_SWAPCHAINSETDEVICE* pInArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINSETDEVICE) IddFunctions[IddCxSwapChainSetDeviceTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs);
}

//
// IDD Function: IddCxSwapChainReleaseAndAcquireBuffer
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    IDARG_OUT_RELEASEANDACQUIREBUFFER* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to release the current buffer in the swapchain and acquire a new one
/// The OS singles the IDARG_IN_SETSWAPCHAIN.hNextSurfaceAvailable event when the next buffer is ready to acquire.
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// E_PENDING indicates that there was not a new buffer to acquire, this should not occur if driver is only calling after the event is signaled
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainReleaseAndAcquireBuffer(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    IDARG_OUT_RELEASEANDACQUIREBUFFER* pOutArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER) IddFunctions[IddCxSwapChainReleaseAndAcquireBufferTableIndex])(IddDriverGlobals, SwapChainObject, pOutArgs);
}

//
// IDD Function: IddCxSwapChainGetDirtyRects
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINGETDIRTYRECTS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETDIRTYRECTS* pInArgs,
    _Out_
    IDARG_OUT_GETDIRTYRECTS* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants retrieve the dirty rects for the current frame
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainGetDirtyRects(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETDIRTYRECTS* pInArgs,
    _Out_
    IDARG_OUT_GETDIRTYRECTS* pOutArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINGETDIRTYRECTS) IddFunctions[IddCxSwapChainGetDirtyRectsTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxSwapChainGetMoveRegions
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINGETMOVEREGIONS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETMOVEREGIONS* pInArgs,
    _Out_
    IDARG_OUT_GETMOVEREGIONS* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants retrieve the move regions for the current frame
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainGetMoveRegions(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETMOVEREGIONS* pInArgs,
    _Out_
    IDARG_OUT_GETMOVEREGIONS* pOutArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINGETMOVEREGIONS) IddFunctions[IddCxSwapChainGetMoveRegionsTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxSwapChainFinishedProcessingFrame
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINFINISHEDPROCESSINGFRAME)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject
    );

/// <summary>
/// An OS callback function the driver calls report all GPU command for processing this frame have been queue
/// For example if the driver copies the buffer to a staging surface so it can lock and copy the
/// pixel data to the CPU then the driver should call this callback once the copy from surface to staging surface
/// has been submitted (eg Dxgi CopyResource API called)
/// If the driver does not call this callback the desktop will not update, it is invalid to call ReleaseAndAcquireBuffer()
/// before calling FinishedProcessingFrame
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code.</returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainFinishedProcessingFrame(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject
    )
{
    return ((PFN_IDDCXSWAPCHAINFINISHEDPROCESSINGFRAME) IddFunctions[IddCxSwapChainFinishedProcessingFrameTableIndex])(IddDriverGlobals, SwapChainObject);
}

//
// IDD Function: IddCxSwapChainReportFrameStatistics
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXSWAPCHAINREPORTFRAMESTATISTICS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_REPORTFRAMESTATISTICS* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls report the frame statics after it has processed a frame completely
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxSwapChainReportFrameStatistics(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_REPORTFRAMESTATISTICS* pInArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINREPORTFRAMESTATISTICS) IddFunctions[IddCxSwapChainReportFrameStatisticsTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs);
}

//
// IDD Function: IddCxGetVersion
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXGETVERSION)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _Out_
    IDARG_OUT_GETVERSION* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls to find the IddCx version
/// </summary>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxGetVersion(
    _Out_
    IDARG_OUT_GETVERSION* pOutArgs
    )
{
    return ((PFN_IDDCXGETVERSION) IddFunctions[IddCxGetVersionTableIndex])(IddDriverGlobals, pOutArgs);
}

//
// IDD Function: IddCxReportCriticalError
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXREPORTCRITICALERROR)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_opt_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_REPORTCRITICALERROR* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls to report a critical error.
/// The OS will bugcheck the driver will the following bugcheck code :
///        (pInArgs->MajorErrorCode+0x100 << 8) + pInArgs->MinorErrorCode
/// Wastson dump will be generated and driver process will terminate and restart
/// according the UMDF driver restart policy.
/// As a user mode memory dump is generated the driver should place any useful
/// debug info on the stack of the function that calls this callback
/// </summary>
/// <param name>
/// <param name="AdapterObject">The adapter object that is the critical error occurred on
/// If the error occurred before a IddCxAdapter was created pass in nullptr</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <returns>
/// If the routine succeeds it never returns to the driver as the driver process will be
/// terminated
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxReportCriticalError(
    _In_opt_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_REPORTCRITICALERROR* pInArgs
    )
{
    return ((PFN_IDDCXREPORTCRITICALERROR) IddFunctions[IddCxReportCriticalErrorTableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
}

//
// IDD Function: IddCxMonitorSetSrmList
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORSETSRMLIST)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_SETSRMLIST* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants pass a HDCP SRM list to
/// the GPU driver associated with the rendering of the specified monitor
/// </summary>
/// <param name="MonitorObject">The monitor object that the SRM list is associated with
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the routine succeeds it returns STATUS_SUCCESS otherwise an appropriate error
/// code.
/// STATUS_GRAPHICS_OPM_NOT_SUPPORTED will be returned if the GPU driver does not
/// support this new functionality.
/// STATUS_GRAPHICS_OPM_INVALID_SRM will be returned if the GPU driver does
/// recognize the format of the SRM list, this include if the driver detected
/// the list had been tampered with
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorSetSrmList(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_SETSRMLIST* pInArgs
    )
{
    return ((PFN_IDDCXMONITORSETSRMLIST) IddFunctions[IddCxMonitorSetSrmListTableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
}

//
// IDD Function: IddCxMonitorGetSrmListVersion
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORGETSRMLISTVERSION)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_GETSRMLISTVERSION* pInArgs,
    _Out_
    IDARG_OUT_GETSRMLISTVERSION* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to retrieve the latest SRM
/// list version stored by the GPU
/// </summary>
/// <param name="MonitorObject">The monitor object that the SRM list is associated with
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it returns STATUS_SUCCESS otherwise an appropriate error
/// code.
/// STATUS_GRAPHICS_OPM_NOT_SUPPORTED will be returned if the GPU driver does not
/// support this new functionality.
/// STATUS_NO_DATA_DETECTED will be returned if the GPU does not have a current SRM
/// list
/// STATUS_BUFFER_TOO_SMALL will be return if the passed in buffer is too small
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorGetSrmListVersion(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_GETSRMLISTVERSION* pInArgs,
    _Out_
    IDARG_OUT_GETSRMLISTVERSION* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORGETSRMLISTVERSION) IddFunctions[IddCxMonitorGetSrmListVersionTableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxAdapterSetRenderAdapter
//
typedef
WDFAPI
VOID
(NTAPI *PFN_IDDCXADAPTERSETRENDERADAPTER)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_ADAPTERSETRENDERADAPTER* pInArgs
    );

/// <summary>
/// An OS callback function the driver can call to set the preferred render adapter
/// used to render the swapchains for the specified adapter
/// </summary>
/// <param name="AdapterObject">The adapter object of the adapter the rendering adapter preference is being set for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>None</returns>
/// <remarks>
/// The driver can call this at anytime to change the preferred render adapter, the driver can use
/// Dxgi enumeration to find the required render adapter LUID.  When this is called
/// the OS will attempt to re-create any existing swapchains onto the specified render adapter and
/// hence the user may see some visual glitches/artifacts.
/// It is recommended that if possible for the driver to make this call before adding any monitors.
/// </remarks>
FORCEINLINE
VOID
IddCxAdapterSetRenderAdapter(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_ADAPTERSETRENDERADAPTER* pInArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    ((PFN_IDDCXADAPTERSETRENDERADAPTER) IddFunctions[IddCxAdapterSetRenderAdapterTableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxAdapterSetRenderAdapter)) {
        ((PFN_IDDCXADAPTERSETRENDERADAPTER) IddFunctions[IddCxAdapterSetRenderAdapterTableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxAdapterSetRenderAdapterTableIndex, FALSE);
    }
#endif
}

//
// IDD Function: IddCxAdapterDisplayConfigUpdate
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXADAPTERDISPLAYCONFIGUPDATE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE* pInArgs
    );

/// <summary>
/// An OS callback function the driver can call to set the preferred render adapter used to
/// render the swapchains for the specified adapter
/// </summary>
/// <param name="AdapterObject">The adapter object of the remote adapter that the display configuration is specified for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// On success STATUS_SUCCESS is returned otherwise an appropriate error code.
/// </returns>
/// <remarks>
/// If STATUS_SUCCESS is returned then the OS has stored the new display configuration specified and
/// asynchronously the changes will reconfigure the swapchains for the monitors as requested.
/// This call will first flush any pending monitor arrivals or departures will be process to ensure
/// list of monitor is current.
/// If the call determines the supplied display configuration is not currently supported by the driver
/// it will return STATUS_INVALID_PARAMETER and the reason will be logged using WPP for debugging
/// purposes, for example is a given resolution/refresh rate are not supported or if an invalid
/// monitor is specified.
/// </remarks>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxAdapterDisplayConfigUpdate(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE* pInArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXADAPTERDISPLAYCONFIGUPDATE) IddFunctions[IddCxAdapterDisplayConfigUpdateTableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxAdapterDisplayConfigUpdate)) {
        return ((PFN_IDDCXADAPTERDISPLAYCONFIGUPDATE) IddFunctions[IddCxAdapterDisplayConfigUpdateTableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
    }
    else {
        return ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxAdapterDisplayConfigUpdateTableIndex, TRUE);
    }
#endif
}

//
// IDD Function: IddCxSwapChainInSystemMemory
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAININSYSTEMMEMORY)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    BOOL* pInSystemMemory
    );

/// <summary>
/// Fills in a boolean value, TRUE when the swapchain buffers are allocated in system memory and false otherwise.
/// Note: Calling this function before calling IddCxSwapChainSetDevice is invalid and will cause an error.
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pInSystemMemory">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainInSystemMemory(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    BOOL* pInSystemMemory
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXSWAPCHAININSYSTEMMEMORY) IddFunctions[IddCxSwapChainInSystemMemoryTableIndex])(IddDriverGlobals, SwapChainObject, pInSystemMemory);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxSwapChainInSystemMemory)) {
        return ((PFN_IDDCXSWAPCHAININSYSTEMMEMORY) IddFunctions[IddCxSwapChainInSystemMemoryTableIndex])(IddDriverGlobals, SwapChainObject, pInSystemMemory);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxSwapChainInSystemMemoryTableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxSwapChainReleaseAndAcquireSystemBuffer
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINRELEASEANDACQUIRESYSTEMBUFFER)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    IDARG_OUT_RELEASEANDACQUIRESYSTEMBUFFER* pOutArgs
    );

/// <summary>
/// Performs a release and acquire on the swapchain, but also maps the buffers for cpu access. Information required
/// to access the buffers is filled into the IDDCX_SYSTEM_BUFFER_INFO struct pointer inside IDARG_OUT_RELEASEANDACQUIRESYSTEMBUFFER
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// E_PENDING indicates that there was not a new buffer to acquire, this should not occur if driver is only calling after the event is signaled
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainReleaseAndAcquireSystemBuffer(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    IDARG_OUT_RELEASEANDACQUIRESYSTEMBUFFER* pOutArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXSWAPCHAINRELEASEANDACQUIRESYSTEMBUFFER) IddFunctions[IddCxSwapChainReleaseAndAcquireSystemBufferTableIndex])(IddDriverGlobals, SwapChainObject, pOutArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxSwapChainReleaseAndAcquireSystemBuffer)) {
        return ((PFN_IDDCXSWAPCHAINRELEASEANDACQUIRESYSTEMBUFFER) IddFunctions[IddCxSwapChainReleaseAndAcquireSystemBufferTableIndex])(IddDriverGlobals, SwapChainObject, pOutArgs);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxSwapChainReleaseAndAcquireSystemBufferTableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxSwapChainGetPhysicallyContiguousAddress
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINGETPHYSICALLYCONTIGUOUSADDRESS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    PHYSICAL_ADDRESS* pSurfaceAddresss
    );

/// <summary>
/// Fills in a PHYSICAL_ADDRESS value of the currently acquired surface if allocated in physically contiguous memory
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pSurfaceAddresss">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK, if the surface was not allocated in physically contiguous memory it will return E_NOINTERFACE
/// On success, pSurfaceAddress is filled with the physical address of the surface
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainGetPhysicallyContiguousAddress(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    PHYSICAL_ADDRESS* pSurfaceAddresss
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXSWAPCHAINGETPHYSICALLYCONTIGUOUSADDRESS) IddFunctions[IddCxSwapChainGetPhysicallyContiguousAddressTableIndex])(IddDriverGlobals, SwapChainObject, pSurfaceAddresss);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxSwapChainGetPhysicallyContiguousAddress)) {
        return ((PFN_IDDCXSWAPCHAINGETPHYSICALLYCONTIGUOUSADDRESS) IddFunctions[IddCxSwapChainGetPhysicallyContiguousAddressTableIndex])(IddDriverGlobals, SwapChainObject, pSurfaceAddresss);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxSwapChainGetPhysicallyContiguousAddressTableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxMonitorQueryHardwareCursor2
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORQUERYHARDWARECURSOR2)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR2* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants obtain the updated cursor information, driver normally only calls
/// this when the event that signals cursor update has triggered.
/// This function is a replacement for IddCxMonitorQueryHardwareCursor() providing more information.
/// </summary>
/// <param name="MonitorObject">This is the OS context handle for this monitor returned by the IddCxMonitorArrival call</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorQueryHardwareCursor2(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR2* pOutArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXMONITORQUERYHARDWARECURSOR2) IddFunctions[IddCxMonitorQueryHardwareCursor2TableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxMonitorQueryHardwareCursor2)) {
        return ((PFN_IDDCXMONITORQUERYHARDWARECURSOR2) IddFunctions[IddCxMonitorQueryHardwareCursor2TableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
    }
    else {
        return ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxMonitorQueryHardwareCursor2TableIndex, TRUE);
    }
#endif
}

//
// IDD Function: IddCxSetRealtimeGPUPriority
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSETREALTIMEGPUPRIORITY)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_SETREALTIMEGPUPRIORITY* pIn
    );

/// <summary>
/// An OS callback function the driver calls if it want to raise the GPU priority of a DirectX device to realtime priority
/// band to ensure GPU work for processing the frame is completed in a timely manor
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSetRealtimeGPUPriority(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_SETREALTIMEGPUPRIORITY* pIn
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXSETREALTIMEGPUPRIORITY) IddFunctions[IddCxSetRealtimeGPUPriorityTableIndex])(IddDriverGlobals, SwapChainObject, pIn);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxSetRealtimeGPUPriority)) {
        return ((PFN_IDDCXSETREALTIMEGPUPRIORITY) IddFunctions[IddCxSetRealtimeGPUPriorityTableIndex])(IddDriverGlobals, SwapChainObject, pIn);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxSetRealtimeGPUPriorityTableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxSwapChainReleaseAndAcquireBuffer2
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER2)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    IDARG_IN_RELEASEANDACQUIREBUFFER2* pInArgs,
    _Out_
    IDARG_OUT_RELEASEANDACQUIREBUFFER2* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to release the current buffer in the swapchain and acquire a new one
/// The OS signals the IDARG_IN_SETSWAPCHAIN.hNextSurfaceAvailable event when the next buffer is ready to acquire.
/// This function differs from IddCxSwapChainReleaseAndAcquireBuffer in that it will return the extended IDDCX_METADATA2 structure.
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// E_PENDING indicates that there was not a new buffer to acquire, this should not occur if driver is only calling after the event is signaled
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxSwapChainReleaseAndAcquireBuffer2(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    IDARG_IN_RELEASEANDACQUIREBUFFER2* pInArgs,
    _Out_
    IDARG_OUT_RELEASEANDACQUIREBUFFER2* pOutArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER2) IddFunctions[IddCxSwapChainReleaseAndAcquireBuffer2TableIndex])(IddDriverGlobals, SwapChainObject, pInArgs, pOutArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxSwapChainReleaseAndAcquireBuffer2)) {
        return ((PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER2) IddFunctions[IddCxSwapChainReleaseAndAcquireBuffer2TableIndex])(IddDriverGlobals, SwapChainObject, pInArgs, pOutArgs);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxSwapChainReleaseAndAcquireBuffer2TableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxMonitorQueryHardwareCursor3
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXMONITORQUERYHARDWARECURSOR3)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR3* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants obtain the updated cursor information, driver normally only calls
/// this when the event that signals cursor update has triggered.
/// This function replaces IddCxMonitorQueryHardwareCursor() and IddCxMonitorQueryHardwareCursor2() providing more information.
/// </summary>
/// <param name="MonitorObject">This is the OS context handle for this monitor returned by the IddCxMonitorCreate call</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxMonitorQueryHardwareCursor3(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR3* pOutArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXMONITORQUERYHARDWARECURSOR3) IddFunctions[IddCxMonitorQueryHardwareCursor3TableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxMonitorQueryHardwareCursor3)) {
        return ((PFN_IDDCXMONITORQUERYHARDWARECURSOR3) IddFunctions[IddCxMonitorQueryHardwareCursor3TableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxMonitorQueryHardwareCursor3TableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxAdapterDisplayConfigUpdate2
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(NTAPI *PFN_IDDCXADAPTERDISPLAYCONFIGUPDATE2)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE2* pInArgs
    );

/// <summary>
/// An OS callback function the remote driver can call to set the display config for monitors connected to an adapter.
/// This function replaces IddCxAdapterDisplayConfigUpdate and allows a driver to both set more information and update only a subset in subsequent calls.
/// </summary>
/// <param name="AdapterObject">The adapter object of the remote adapter that the display configuration is specified for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// On success STATUS_SUCCESS is returned otherwise an appropriate error code.
/// </returns>
/// <remarks>
/// If STATUS_SUCCESS is returned then the OS has stored the new display configuration specified and
/// asynchronously the changes will reconfigure the swapchains for the monitors as requested.
/// This call will first flush any pending monitor arrivals or departures to ensure the list of monitors is current.
/// If the call determines the supplied display configuration is not currently supported by the driver
/// it will return STATUS_INVALID_PARAMETER and the reason will be logged using WPP for debugging
/// purposes, for example is a given resolution/refresh rate are not supported or if an invalid
/// monitor is specified.
/// </remarks>
_Must_inspect_result_
FORCEINLINE
HRESULT
IddCxAdapterDisplayConfigUpdate2(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_ADAPTERDISPLAYCONFIGUPDATE2* pInArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXADAPTERDISPLAYCONFIGUPDATE2) IddFunctions[IddCxAdapterDisplayConfigUpdate2TableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxAdapterDisplayConfigUpdate2)) {
        return ((PFN_IDDCXADAPTERDISPLAYCONFIGUPDATE2) IddFunctions[IddCxAdapterDisplayConfigUpdate2TableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
    }
    else {
        ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxAdapterDisplayConfigUpdate2TableIndex, FALSE);
        return (HRESULT)0;
    }
#endif
}

//
// IDD Function: IddCxMonitorUpdateModes2
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(NTAPI *PFN_IDDCXMONITORUPDATEMODES2)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_UPDATEMODES2* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls to update the mode list
/// </summary>
/// <param name="MonitorObject">The monitor object being updated</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
_Must_inspect_result_
FORCEINLINE
NTSTATUS
IddCxMonitorUpdateModes2(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_UPDATEMODES2* pInArgs
    )
{
#if defined(IDD_EVERYTHING_ALWAYS_AVAILABLE)
    return ((PFN_IDDCXMONITORUPDATEMODES2) IddFunctions[IddCxMonitorUpdateModes2TableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
#else
    if (IDD_IS_FUNCTION_AVAILABLE(IddCxMonitorUpdateModes2)) {
        return ((PFN_IDDCXMONITORUPDATEMODES2) IddFunctions[IddCxMonitorUpdateModes2TableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
    }
    else {
        return ((PFN_WDFDRIVERERRORREPORTAPIMISSING) WdfFunctions[WdfDriverErrorReportApiMissingTableIndex])(WdfDriverGlobals, WdfGetDriver(), IddFrameworkExtensionName, IddCxMonitorUpdateModes2TableIndex, TRUE);
    }
#endif
}



#pragma endregion

WDF_EXTERN_C_END

#endif // _IDDCX_H_


